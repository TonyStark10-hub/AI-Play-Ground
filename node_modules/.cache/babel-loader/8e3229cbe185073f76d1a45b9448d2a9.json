{"ast":null,"code":"/**\n    * @license\n    * Copyright 2021 Google LLC. All Rights Reserved.\n    * Licensed under the Apache License, Version 2.0 (the \"License\");\n    * you may not use this file except in compliance with the License.\n    * You may obtain a copy of the License at\n    *\n    * http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing, software\n    * distributed under the License is distributed on an \"AS IS\" BASIS,\n    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    * See the License for the specific language governing permissions and\n    * limitations under the License.\n    * =============================================================================\n    */\nimport * as tf from \"@tensorflow/tfjs-core\";\nimport { tidy, squeeze, Tensor, util, browser, image, reverse, pad3d, sigmoid, expandDims, argMax, reshape, oneHot, mul, cast, greater, scalar, range, matMul, add, sub, div, equal, getBackend, engine, tensor, backend } from \"@tensorflow/tfjs-core\";\nimport { loadGraphModel } from \"@tensorflow/tfjs-converter\";\n\nvar extendStatics = function (e, t) {\n  return (extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (e, t) {\n    e.__proto__ = t;\n  } || function (e, t) {\n    for (var n in t) t.hasOwnProperty(n) && (e[n] = t[n]);\n  })(e, t);\n};\n\nfunction __extends(e, t) {\n  function n() {\n    this.constructor = e;\n  }\n\n  extendStatics(e, t), e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype, new n());\n}\n\nvar __assign = function () {\n  return (__assign = Object.assign || function (e) {\n    for (var t, n = 1, r = arguments.length; n < r; n++) for (var o in t = arguments[n]) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);\n\n    return e;\n  }).apply(this, arguments);\n};\n\nfunction __awaiter(e, t, n, r) {\n  return new (n || (n = Promise))(function (o, i) {\n    function a(e) {\n      try {\n        d(r.next(e));\n      } catch (e) {\n        i(e);\n      }\n    }\n\n    function s(e) {\n      try {\n        d(r.throw(e));\n      } catch (e) {\n        i(e);\n      }\n    }\n\n    function d(e) {\n      e.done ? o(e.value) : new n(function (t) {\n        t(e.value);\n      }).then(a, s);\n    }\n\n    d((r = r.apply(e, t || [])).next());\n  });\n}\n\nfunction __generator(e, t) {\n  var n,\n      r,\n      o,\n      i,\n      a = {\n    label: 0,\n    sent: function () {\n      if (1 & o[0]) throw o[1];\n      return o[1];\n    },\n    trys: [],\n    ops: []\n  };\n  return i = {\n    next: s(0),\n    throw: s(1),\n    return: s(2)\n  }, \"function\" == typeof Symbol && (i[Symbol.iterator] = function () {\n    return this;\n  }), i;\n\n  function s(i) {\n    return function (s) {\n      return function (i) {\n        if (n) throw new TypeError(\"Generator is already executing.\");\n\n        for (; a;) try {\n          if (n = 1, r && (o = 2 & i[0] ? r.return : i[0] ? r.throw || ((o = r.return) && o.call(r), 0) : r.next) && !(o = o.call(r, i[1])).done) return o;\n\n          switch (r = 0, o && (i = [2 & i[0], o.value]), i[0]) {\n            case 0:\n            case 1:\n              o = i;\n              break;\n\n            case 4:\n              return a.label++, {\n                value: i[1],\n                done: !1\n              };\n\n            case 5:\n              a.label++, r = i[1], i = [0];\n              continue;\n\n            case 7:\n              i = a.ops.pop(), a.trys.pop();\n              continue;\n\n            default:\n              if (!(o = (o = a.trys).length > 0 && o[o.length - 1]) && (6 === i[0] || 2 === i[0])) {\n                a = 0;\n                continue;\n              }\n\n              if (3 === i[0] && (!o || i[1] > o[0] && i[1] < o[3])) {\n                a.label = i[1];\n                break;\n              }\n\n              if (6 === i[0] && a.label < o[1]) {\n                a.label = o[1], o = i;\n                break;\n              }\n\n              if (o && a.label < o[2]) {\n                a.label = o[2], a.ops.push(i);\n                break;\n              }\n\n              o[2] && a.ops.pop(), a.trys.pop();\n              continue;\n          }\n\n          i = t.call(e, a);\n        } catch (e) {\n          i = [6, e], r = 0;\n        } finally {\n          n = o = 0;\n        }\n\n        if (5 & i[0]) throw i[1];\n        return {\n          value: i[0] ? i[1] : void 0,\n          done: !0\n        };\n      }([i, s]);\n    };\n  }\n}\n\nfunction toFlattenedOneHotPartMap(e) {\n  var t = e.shape[2],\n      n = argMax(e, 2),\n      r = reshape(n, [-1]);\n  return oneHot(r, t);\n}\n\nfunction clipByMask2d(e, t) {\n  return mul(e, t);\n}\n\nfunction toMaskTensor(e, t) {\n  return tidy(function () {\n    return cast(greater(e, scalar(t)), \"int32\");\n  });\n}\n\nfunction decodePartSegmentation(e, t) {\n  var n = t.shape,\n      r = n[0],\n      o = n[1],\n      i = n[2];\n  return tidy(function () {\n    var n = toFlattenedOneHotPartMap(t),\n        a = expandDims(range(0, i, 1, \"int32\"), 1),\n        s = cast(matMul(n, a), \"int32\"),\n        d = reshape(s, [r, o]),\n        u = add(d, scalar(1, \"int32\"));\n    return sub(clipByMask2d(u, e), scalar(1, \"int32\"));\n  });\n}\n\nfunction decodeOnlyPartSegmentation(e) {\n  var t = e.shape,\n      n = t[0],\n      r = t[1],\n      o = t[2];\n  return tidy(function () {\n    var t = toFlattenedOneHotPartMap(e),\n        i = expandDims(range(0, o, 1, \"int32\"), 1),\n        a = cast(matMul(t, i), \"int32\");\n    return reshape(a, [n, r]);\n  });\n}\n\nvar BaseModel = function () {\n  function e(e, t) {\n    this.model = e, this.outputStride = t;\n    var n = this.model.inputs[0].shape;\n    util.assert(-1 === n[1] && -1 === n[2], function () {\n      return \"Input shape [\" + n[1] + \", \" + n[2] + \"] must both be equal to or -1\";\n    });\n  }\n\n  return e.prototype.predict = function (e) {\n    var t = this;\n    return tidy(function () {\n      var n = t.preprocessInput(cast(e, \"float32\")),\n          r = expandDims(n, 0),\n          o = t.model.predict(r).map(function (e) {\n        return squeeze(e, [0]);\n      }),\n          i = t.nameOutputResults(o);\n      return {\n        heatmapScores: sigmoid(i.heatmap),\n        offsets: i.offsets,\n        displacementFwd: i.displacementFwd,\n        displacementBwd: i.displacementBwd,\n        segmentation: i.segmentation,\n        partHeatmaps: i.partHeatmaps,\n        longOffsets: i.longOffsets,\n        partOffsets: i.partOffsets\n      };\n    });\n  }, e.prototype.dispose = function () {\n    this.model.dispose();\n  }, e;\n}(),\n    MobileNet = function (e) {\n  function t() {\n    return null !== e && e.apply(this, arguments) || this;\n  }\n\n  return __extends(t, e), t.prototype.preprocessInput = function (e) {\n    return tidy(function () {\n      return sub(div(e, 127.5), 1);\n    });\n  }, t.prototype.nameOutputResults = function (e) {\n    return {\n      offsets: e[0],\n      segmentation: e[1],\n      partHeatmaps: e[2],\n      longOffsets: e[3],\n      heatmap: e[4],\n      displacementFwd: e[5],\n      displacementBwd: e[6],\n      partOffsets: e[7]\n    };\n  }, t;\n}(BaseModel),\n    PART_NAMES = [\"nose\", \"leftEye\", \"rightEye\", \"leftEar\", \"rightEar\", \"leftShoulder\", \"rightShoulder\", \"leftElbow\", \"rightElbow\", \"leftWrist\", \"rightWrist\", \"leftHip\", \"rightHip\", \"leftKnee\", \"rightKnee\", \"leftAnkle\", \"rightAnkle\"],\n    NUM_KEYPOINTS = PART_NAMES.length,\n    PART_IDS = PART_NAMES.reduce(function (e, t, n) {\n  return e[t] = n, e;\n}, {}),\n    CONNECTED_PART_NAMES = [[\"leftHip\", \"leftShoulder\"], [\"leftElbow\", \"leftShoulder\"], [\"leftElbow\", \"leftWrist\"], [\"leftHip\", \"leftKnee\"], [\"leftKnee\", \"leftAnkle\"], [\"rightHip\", \"rightShoulder\"], [\"rightElbow\", \"rightShoulder\"], [\"rightElbow\", \"rightWrist\"], [\"rightHip\", \"rightKnee\"], [\"rightKnee\", \"rightAnkle\"], [\"leftShoulder\", \"rightShoulder\"], [\"leftHip\", \"rightHip\"]],\n    POSE_CHAIN = [[\"nose\", \"leftEye\"], [\"leftEye\", \"leftEar\"], [\"nose\", \"rightEye\"], [\"rightEye\", \"rightEar\"], [\"nose\", \"leftShoulder\"], [\"leftShoulder\", \"leftElbow\"], [\"leftElbow\", \"leftWrist\"], [\"leftShoulder\", \"leftHip\"], [\"leftHip\", \"leftKnee\"], [\"leftKnee\", \"leftAnkle\"], [\"nose\", \"rightShoulder\"], [\"rightShoulder\", \"rightElbow\"], [\"rightElbow\", \"rightWrist\"], [\"rightShoulder\", \"rightHip\"], [\"rightHip\", \"rightKnee\"], [\"rightKnee\", \"rightAnkle\"]],\n    CONNECTED_PART_INDICES = CONNECTED_PART_NAMES.map(function (e) {\n  var t = e[0],\n      n = e[1];\n  return [PART_IDS[t], PART_IDS[n]];\n});\n\nfunction getScale(e, t, n) {\n  var r = e[0],\n      o = e[1],\n      i = t[0],\n      a = t[1],\n      s = n.top,\n      d = n.bottom;\n  return [a / (n.left + n.right + o), i / (s + d + r)];\n}\n\nfunction getOffsetPoint(e, t, n, r) {\n  return {\n    y: r.get(e, t, n),\n    x: r.get(e, t, n + NUM_KEYPOINTS)\n  };\n}\n\nfunction getImageCoords(e, t, n) {\n  var r = getOffsetPoint(e.heatmapY, e.heatmapX, e.id, n),\n      o = r.y,\n      i = r.x;\n  return {\n    x: e.heatmapX * t + i,\n    y: e.heatmapY * t + o\n  };\n}\n\nfunction clamp(e, t, n) {\n  return e < t ? t : e > n ? n : e;\n}\n\nfunction squaredDistance(e, t, n, r) {\n  var o = n - e,\n      i = r - t;\n  return o * o + i * i;\n}\n\nfunction addVectors(e, t) {\n  return {\n    x: e.x + t.x,\n    y: e.y + t.y\n  };\n}\n\nfunction computeDistance(e, t, n) {\n  void 0 === n && (n = .3);\n\n  for (var r = 0, o = 0, i = 0; i < e.length; i++) t.keypoints[i].score > n && (o += 1, r += Math.pow(e[i].x - t.keypoints[i].position.x, 2) + Math.pow(e[i].y - t.keypoints[i].position.y, 2));\n\n  return 0 === o ? r = 1 / 0 : r /= o, r;\n}\n\nfunction convertToPositionInOuput(e, t, n, r) {\n  var o = t[0],\n      i = t[1],\n      a = n[0],\n      s = n[1],\n      d = Math.round(((o + e.y + 1) * s - 1) / r);\n  return {\n    x: Math.round(((i + e.x + 1) * a - 1) / r),\n    y: d\n  };\n}\n\nfunction getEmbedding(e, t, n, r, o, i, a) {\n  for (var s = a[0], d = a[1], u = n(e), l = u.y * r + u.x, f = o[NUM_KEYPOINTS * (2 * l) + t], c = o[NUM_KEYPOINTS * (2 * l + 1) + t], p = e.y + f, h = e.x + c, m = 0; m < i; m++) {\n    p = Math.min(p, s - 1);\n    var g = n({\n      x: h = Math.min(h, d - 1),\n      y: p\n    }),\n        v = g.y * r + g.x;\n    p += f = o[NUM_KEYPOINTS * (2 * v) + t], h += c = o[NUM_KEYPOINTS * (2 * v + 1) + t];\n  }\n\n  return {\n    x: h,\n    y: p\n  };\n}\n\nfunction matchEmbeddingToInstance(e, t, n, r, o, i, a, s, d, u) {\n  for (var l = o[0], f = o[1], c = i[0], p = i[1], h = s[0], m = s[1], g = [], v = function (e) {\n    return convertToPositionInOuput(e, [l, f], [c, p], d);\n  }, S = 0; S < r; S++) {\n    var _ = getEmbedding(e, S, v, a, t, u, [h, m]);\n\n    g.push(_);\n  }\n\n  for (var I = -1, w = 1 / 0, E = 0; E < n.length; E++) {\n    var T = computeDistance(g, n[E]);\n    T < w && (I = E, w = T);\n  }\n\n  return I;\n}\n\nfunction getOutputResolution(e, t) {\n  var n = e[0],\n      r = e[1];\n  return [Math.round((r - 1) / t + 1), Math.round((n - 1) / t + 1)];\n}\n\nfunction decodeMultipleMasksCPU(e, t, n, r, o, i, a, s, d, u) {\n  var l = a[0],\n      f = a[1];\n  void 0 === u && (u = 5);\n\n  for (var c = n.map(function (e) {\n    return new Uint8Array(r * o).fill(0);\n  }), p = s.top, h = s.left, m = getScale([r, o], [l, f], s), g = m[0], v = m[1], S = getOutputResolution([l, f], i)[0], _ = 0; _ < r; _ += 1) for (var I = 0; I < o; I += 1) {\n    var w = _ * o + I;\n\n    if (1 === e[w]) {\n      var E = matchEmbeddingToInstance({\n        x: I,\n        y: _\n      }, t, n, u, [p, h], [g, v], S, [r, o], i, d);\n      E >= 0 && (c[E][w] = 1);\n    }\n  }\n\n  return c;\n}\n\nfunction decodeMultiplePartMasksCPU(e, t, n, r, o, i, a, s, d, u, l) {\n  var f = s[0],\n      c = s[1];\n  void 0 === l && (l = 5);\n\n  for (var p = r.map(function (e) {\n    return new Int32Array(o * i).fill(-1);\n  }), h = d.top, m = d.left, g = getScale([o, i], [f, c], d), v = g[0], S = g[1], _ = getOutputResolution([f, c], a)[0], I = 0; I < o; I += 1) for (var w = 0; w < i; w += 1) {\n    var E = I * i + w;\n\n    if (1 === e[E]) {\n      var T = matchEmbeddingToInstance({\n        x: w,\n        y: I\n      }, t, r, l, [h, m], [v, S], _, [o, i], a, u);\n      T >= 0 && (p[T][E] = n[E]);\n    }\n  }\n\n  return p;\n}\n\nfunction decodeMultipleMasksWebGl(e, t, n, r, o, i, a, s, d, u, l) {\n  for (var f = a[0], c = a[1], p = e.shape, h = p[0], m = p[1], g = t.shape.slice(0, 2), v = g[0], S = g[1], _ = reshape(t, [v, S, 2, NUM_KEYPOINTS]), I = new Float32Array(l * NUM_KEYPOINTS * 3).fill(0), w = 0; w < n.length; w++) for (var E = w * NUM_KEYPOINTS * 3, T = n[w], N = 0; N < NUM_KEYPOINTS; N++) {\n    var A = T.keypoints[N],\n        P = E + 3 * N;\n    I[P] = A.score, I[P + 1] = A.position.y, I[P + 2] = A.position.x;\n  }\n\n  var y = getScale([r, o], [f, c], s),\n      O = y[0],\n      M = y[1],\n      R = tensor(I, [l, NUM_KEYPOINTS, 3]),\n      b = s.top,\n      C = s.left,\n      x = {\n    variableNames: [\"segmentation\", \"longOffsets\", \"poses\"],\n    outputShape: [h, m],\n    userCode: \"\\n    int convertToPositionInOutput(int pos, int pad, float scale, int stride) {\\n      return round(((float(pos + pad) + 1.0) * scale - 1.0) / float(stride));\\n    }\\n\\n    float convertToPositionInOutputFloat(\\n        int pos, int pad, float scale, int stride) {\\n      return ((float(pos + pad) + 1.0) * scale - 1.0) / float(stride);\\n    }\\n\\n    float dist(float x1, float y1, float x2, float y2) {\\n      return pow(x1 - x2, 2.0) + pow(y1 - y2, 2.0);\\n    }\\n\\n    float sampleLongOffsets(float h, float w, int d, int k) {\\n      float fh = fract(h);\\n      float fw = fract(w);\\n      int clH = int(ceil(h));\\n      int clW = int(ceil(w));\\n      int flH = int(floor(h));\\n      int flW = int(floor(w));\\n      float o11 = getLongOffsets(flH, flW, d, k);\\n      float o12 = getLongOffsets(flH, clW, d, k);\\n      float o21 = getLongOffsets(clH, flW, d, k);\\n      float o22 = getLongOffsets(clH, clW, d, k);\\n      float o1 = mix(o11, o12, fw);\\n      float o2 = mix(o21, o22, fw);\\n      return mix(o1, o2, fh);\\n    }\\n\\n    int findNearestPose(int h, int w) {\\n      float prob = getSegmentation(h, w);\\n      if (prob < 1.0) {\\n        return -1;\\n      }\\n\\n      // Done(Tyler): convert from output space h/w to strided space.\\n      float stridedH = convertToPositionInOutputFloat(\\n        h, \" + b + \", \" + M + \", \" + i + \");\\n      float stridedW = convertToPositionInOutputFloat(\\n        w, \" + C + \", \" + O + \", \" + i + \");\\n\\n      float minDist = 1000000.0;\\n      int iMin = -1;\\n      for (int i = 0; i < \" + l + \"; i++) {\\n        float curDistSum = 0.0;\\n        int numKpt = 0;\\n        for (int k = 0; k < \" + NUM_KEYPOINTS + \"; k++) {\\n          float dy = sampleLongOffsets(stridedH, stridedW, 0, k);\\n          float dx = sampleLongOffsets(stridedH, stridedW, 1, k);\\n\\n          float y = float(h) + dy;\\n          float x = float(w) + dx;\\n\\n          for (int s = 0; s < \" + d + \"; s++) {\\n            int yRounded = round(min(y, float(\" + (r - 1) + \")));\\n            int xRounded = round(min(x, float(\" + (o - 1) + \")));\\n\\n            float yStrided = convertToPositionInOutputFloat(\\n              yRounded, \" + b + \", \" + M + \", \" + i + \");\\n            float xStrided = convertToPositionInOutputFloat(\\n              xRounded, \" + C + \", \" + O + \", \" + i + \");\\n\\n            float dy = sampleLongOffsets(yStrided, xStrided, 0, k);\\n            float dx = sampleLongOffsets(yStrided, xStrided, 1, k);\\n\\n            y = y + dy;\\n            x = x + dx;\\n          }\\n\\n          float poseScore = getPoses(i, k, 0);\\n          float poseY = getPoses(i, k, 1);\\n          float poseX = getPoses(i, k, 2);\\n          if (poseScore > \" + u + \") {\\n            numKpt = numKpt + 1;\\n            curDistSum = curDistSum + dist(x, y, poseX, poseY);\\n          }\\n        }\\n        if (numKpt > 0 && curDistSum / float(numKpt) < minDist) {\\n          minDist = curDistSum / float(numKpt);\\n          iMin = i;\\n        }\\n      }\\n      return iMin;\\n    }\\n\\n    void main() {\\n        ivec2 coords = getOutputCoords();\\n        int nearestPose = findNearestPose(coords[0], coords[1]);\\n        setOutput(float(nearestPose));\\n      }\\n  \"\n  };\n  return backend().compileAndRun(x, [e, _, R]);\n}\n\nfunction toPersonKSegmentation(e, t) {\n  return tidy(function () {\n    return cast(equal(e, scalar(t)), \"int32\");\n  });\n}\n\nfunction toPersonKPartSegmentation(e, t, n) {\n  return tidy(function () {\n    return sub(mul(cast(equal(e, scalar(n)), \"int32\"), add(t, 1)), 1);\n  });\n}\n\nfunction isWebGlBackend() {\n  return \"webgl\" === getBackend();\n}\n\nfunction decodePersonInstanceMasks(e, t, n, r, o, i, a, s, d, u, l, f) {\n  var c = a[0],\n      p = a[1];\n  return void 0 === d && (d = .2), void 0 === u && (u = 8), void 0 === l && (l = .3), void 0 === f && (f = 10), __awaiter(this, void 0, void 0, function () {\n    var a, h, m, g, v;\n    return __generator(this, function (S) {\n      switch (S.label) {\n        case 0:\n          return a = n.filter(function (e) {\n            return e.score >= d;\n          }), isWebGlBackend() ? (m = tidy(function () {\n            var n = decodeMultipleMasksWebGl(e, t, a, r, o, i, [c, p], s, u, l, f),\n                d = engine().makeTensorFromDataId(n.dataId, n.shape, n.dtype);\n            return a.map(function (e, t) {\n              return toPersonKSegmentation(d, t);\n            });\n          }), [4, Promise.all(m.map(function (e) {\n            return e.data();\n          }))]) : [3, 2];\n\n        case 1:\n          return h = S.sent(), m.forEach(function (e) {\n            return e.dispose();\n          }), [3, 5];\n\n        case 2:\n          return [4, e.data()];\n\n        case 3:\n          return g = S.sent(), [4, t.data()];\n\n        case 4:\n          v = S.sent(), h = decodeMultipleMasksCPU(g, v, a, r, o, i, [c, p], s, u), S.label = 5;\n\n        case 5:\n          return [2, h.map(function (e, t) {\n            return {\n              data: e,\n              pose: a[t],\n              width: o,\n              height: r\n            };\n          })];\n      }\n    });\n  });\n}\n\nfunction decodePersonInstancePartMasks(e, t, n, r, o, i, a, s, d, u, l, f, c) {\n  var p = s[0],\n      h = s[1];\n  return void 0 === u && (u = .2), void 0 === l && (l = 8), void 0 === f && (f = .3), void 0 === c && (c = 10), __awaiter(this, void 0, void 0, function () {\n    var s, m, g, v, S, _;\n\n    return __generator(this, function (I) {\n      switch (I.label) {\n        case 0:\n          return s = r.filter(function (e) {\n            return e.score >= u;\n          }), isWebGlBackend() ? (g = tidy(function () {\n            var r = decodeMultipleMasksWebGl(e, t, s, o, i, a, [p, h], d, l, f, c),\n                u = engine().makeTensorFromDataId(r.dataId, r.shape, r.dtype);\n            return s.map(function (e, t) {\n              return toPersonKPartSegmentation(u, n, t);\n            });\n          }), [4, Promise.all(g.map(function (e) {\n            return e.data();\n          }))]) : [3, 2];\n\n        case 1:\n          return m = I.sent(), g.forEach(function (e) {\n            return e.dispose();\n          }), [3, 6];\n\n        case 2:\n          return [4, e.data()];\n\n        case 3:\n          return v = I.sent(), [4, t.data()];\n\n        case 4:\n          return S = I.sent(), [4, n.data()];\n\n        case 5:\n          _ = I.sent(), m = decodeMultiplePartMasksCPU(v, S, _, s, o, i, a, [p, h], d, l), I.label = 6;\n\n        case 6:\n          return [2, m.map(function (e, t) {\n            return {\n              pose: s[t],\n              data: e,\n              height: o,\n              width: i\n            };\n          })];\n      }\n    });\n  });\n}\n\nfunction half(e) {\n  return Math.floor(e / 2);\n}\n\nvar MaxHeap = function () {\n  function e(e, t) {\n    this.priorityQueue = new Array(e), this.numberOfElements = -1, this.getElementValue = t;\n  }\n\n  return e.prototype.enqueue = function (e) {\n    this.priorityQueue[++this.numberOfElements] = e, this.swim(this.numberOfElements);\n  }, e.prototype.dequeue = function () {\n    var e = this.priorityQueue[0];\n    return this.exchange(0, this.numberOfElements--), this.sink(0), this.priorityQueue[this.numberOfElements + 1] = null, e;\n  }, e.prototype.empty = function () {\n    return -1 === this.numberOfElements;\n  }, e.prototype.size = function () {\n    return this.numberOfElements + 1;\n  }, e.prototype.all = function () {\n    return this.priorityQueue.slice(0, this.numberOfElements + 1);\n  }, e.prototype.max = function () {\n    return this.priorityQueue[0];\n  }, e.prototype.swim = function (e) {\n    for (; e > 0 && this.less(half(e), e);) this.exchange(e, half(e)), e = half(e);\n  }, e.prototype.sink = function (e) {\n    for (; 2 * e <= this.numberOfElements;) {\n      var t = 2 * e;\n      if (t < this.numberOfElements && this.less(t, t + 1) && t++, !this.less(e, t)) break;\n      this.exchange(e, t), e = t;\n    }\n  }, e.prototype.getValueAt = function (e) {\n    return this.getElementValue(this.priorityQueue[e]);\n  }, e.prototype.less = function (e, t) {\n    return this.getValueAt(e) < this.getValueAt(t);\n  }, e.prototype.exchange = function (e, t) {\n    var n = this.priorityQueue[e];\n    this.priorityQueue[e] = this.priorityQueue[t], this.priorityQueue[t] = n;\n  }, e;\n}();\n\nfunction scoreIsMaximumInLocalWindow(e, t, n, r, o, i) {\n  for (var a = i.shape, s = a[0], d = a[1], u = !0, l = Math.max(n - o, 0), f = Math.min(n + o + 1, s), c = l; c < f; ++c) {\n    for (var p = Math.max(r - o, 0), h = Math.min(r + o + 1, d), m = p; m < h; ++m) if (i.get(c, m, e) > t) {\n      u = !1;\n      break;\n    }\n\n    if (!u) break;\n  }\n\n  return u;\n}\n\nfunction buildPartWithScoreQueue(e, t, n) {\n  for (var r = n.shape, o = r[0], i = r[1], a = r[2], s = new MaxHeap(o * i * a, function (e) {\n    return e.score;\n  }), d = 0; d < o; ++d) for (var u = 0; u < i; ++u) for (var l = 0; l < a; ++l) {\n    var f = n.get(d, u, l);\n    f < e || scoreIsMaximumInLocalWindow(l, f, d, u, t, n) && s.enqueue({\n      score: f,\n      part: {\n        heatmapY: d,\n        heatmapX: u,\n        id: l\n      }\n    });\n  }\n\n  return s;\n}\n\nvar parentChildrenTuples = POSE_CHAIN.map(function (e) {\n  var t = e[0],\n      n = e[1];\n  return [PART_IDS[t], PART_IDS[n]];\n}),\n    parentToChildEdges = parentChildrenTuples.map(function (e) {\n  return e[1];\n}),\n    childToParentEdges = parentChildrenTuples.map(function (e) {\n  return e[0];\n});\n\nfunction getDisplacement(e, t, n) {\n  var r = n.shape[2] / 2;\n  return {\n    y: n.get(t.y, t.x, e),\n    x: n.get(t.y, t.x, r + e)\n  };\n}\n\nfunction getStridedIndexNearPoint(e, t, n, r) {\n  return {\n    y: clamp(Math.round(e.y / t), 0, n - 1),\n    x: clamp(Math.round(e.x / t), 0, r - 1)\n  };\n}\n\nfunction traverseToTargetKeypoint(e, t, n, r, o, i, a, s) {\n  void 0 === s && (s = 2);\n\n  for (var d = r.shape, u = d[0], l = d[1], f = getDisplacement(e, getStridedIndexNearPoint(t.position, i, u, l), a), c = addVectors(t.position, f), p = 0; p < s; p++) {\n    var h = getStridedIndexNearPoint(c, i, u, l),\n        m = getOffsetPoint(h.y, h.x, n, o);\n    c = addVectors({\n      x: h.x * i,\n      y: h.y * i\n    }, {\n      x: m.x,\n      y: m.y\n    });\n  }\n\n  var g = getStridedIndexNearPoint(c, i, u, l),\n      v = r.get(g.y, g.x, n);\n  return {\n    position: c,\n    part: PART_NAMES[n],\n    score: v\n  };\n}\n\nfunction decodePose(e, t, n, r, o, i) {\n  var a = t.shape[2],\n      s = parentToChildEdges.length,\n      d = new Array(a),\n      u = e.part,\n      l = e.score,\n      f = getImageCoords(u, r, n);\n  d[u.id] = {\n    score: l,\n    part: PART_NAMES[u.id],\n    position: f\n  };\n\n  for (var c = s - 1; c >= 0; --c) {\n    var p = parentToChildEdges[c],\n        h = childToParentEdges[c];\n    d[p] && !d[h] && (d[h] = traverseToTargetKeypoint(c, d[p], h, t, n, r, i));\n  }\n\n  for (c = 0; c < s; ++c) {\n    p = childToParentEdges[c], h = parentToChildEdges[c];\n    d[p] && !d[h] && (d[h] = traverseToTargetKeypoint(c, d[p], h, t, n, r, o));\n  }\n\n  return d;\n}\n\nfunction withinNmsRadiusOfCorrespondingPoint(e, t, n, r) {\n  var o = n.x,\n      i = n.y;\n  return e.some(function (e) {\n    var n = e.keypoints[r].position;\n    return squaredDistance(i, o, n.y, n.x) <= t;\n  });\n}\n\nfunction getInstanceScore(e, t, n) {\n  return n.reduce(function (n, r, o) {\n    var i = r.position,\n        a = r.score;\n    return withinNmsRadiusOfCorrespondingPoint(e, t, i, o) || (n += a), n;\n  }, 0) / n.length;\n}\n\nvar kLocalMaximumRadius = 1;\n\nfunction decodeMultiplePoses(e, t, n, r, o, i, a, s) {\n  void 0 === a && (a = .5), void 0 === s && (s = 20);\n\n  for (var d = [], u = buildPartWithScoreQueue(a, kLocalMaximumRadius, e), l = s * s; d.length < i && !u.empty();) {\n    var f = u.dequeue();\n\n    if (!withinNmsRadiusOfCorrespondingPoint(d, l, getImageCoords(f.part, o, t), f.part.id)) {\n      var c = decodePose(f, e, t, o, n, r),\n          p = getInstanceScore(d, l, c);\n      d.push({\n        keypoints: c,\n        score: p\n      });\n    }\n  }\n\n  return d;\n}\n\nvar _a,\n    imageNetMean = [-123.15, -115.9, -103.06],\n    ResNet = function (e) {\n  function t() {\n    return null !== e && e.apply(this, arguments) || this;\n  }\n\n  return __extends(t, e), t.prototype.preprocessInput = function (e) {\n    return add(e, imageNetMean);\n  }, t.prototype.nameOutputResults = function (e) {\n    var t = e[0],\n        n = e[1],\n        r = e[2],\n        o = e[3],\n        i = e[4],\n        a = e[5];\n    return {\n      offsets: i,\n      segmentation: e[6],\n      partHeatmaps: a,\n      longOffsets: o,\n      heatmap: r,\n      displacementFwd: n,\n      displacementBwd: t,\n      partOffsets: e[7]\n    };\n  }, t;\n}(BaseModel),\n    RESNET50_BASE_URL = \"https://storage.googleapis.com/tfjs-models/savedmodel/bodypix/resnet50/\",\n    MOBILENET_BASE_URL = \"https://storage.googleapis.com/tfjs-models/savedmodel/bodypix/mobilenet/\";\n\nfunction resNet50SavedModel(e, t) {\n  var n = \"model-stride\" + e + \".json\";\n  return 4 === t ? RESNET50_BASE_URL + \"float/\" + n : RESNET50_BASE_URL + \"quant\" + t + \"/\" + n;\n}\n\nfunction mobileNetSavedModel(e, t, n) {\n  var r = {\n    1: \"100\",\n    .75: \"075\",\n    .5: \"050\"\n  },\n      o = \"model-stride\" + e + \".json\";\n  return 4 === n ? MOBILENET_BASE_URL + \"float/\" + r[t] + \"/\" + o : MOBILENET_BASE_URL + \"quant\" + n + \"/\" + r[t] + \"/\" + o;\n}\n\nfunction getSizeFromImageLikeElement(e) {\n  if (0 !== e.offsetHeight && 0 !== e.offsetWidth) return [e.offsetHeight, e.offsetWidth];\n  if (null != e.height && null != e.width) return [e.height, e.width];\n  throw new Error(\"HTMLImageElement must have height and width attributes set.\");\n}\n\nfunction getSizeFromVideoElement(e) {\n  return e.hasAttribute(\"height\") && e.hasAttribute(\"width\") ? [e.height, e.width] : [e.videoHeight, e.videoWidth];\n}\n\nfunction getInputSize(e) {\n  if (\"undefined\" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || \"undefined\" != typeof HTMLImageElement && e instanceof HTMLImageElement) return getSizeFromImageLikeElement(e);\n  if (\"undefined\" != typeof ImageData && e instanceof ImageData) return [e.height, e.width];\n  if (\"undefined\" != typeof HTMLVideoElement && e instanceof HTMLVideoElement) return getSizeFromVideoElement(e);\n  if (e instanceof Tensor) return [e.shape[0], e.shape[1]];\n  throw new Error(\"error: Unknown input type: \" + e + \".\");\n}\n\nfunction isValidInputResolution(e, t) {\n  return (e - 1) % t == 0;\n}\n\nfunction toValidInputResolution(e, t) {\n  return isValidInputResolution(e, t) ? e : Math.floor(e / t) * t + 1;\n}\n\nvar INTERNAL_RESOLUTION_STRING_OPTIONS = {\n  low: \"low\",\n  medium: \"medium\",\n  high: \"high\",\n  full: \"full\"\n},\n    INTERNAL_RESOLUTION_PERCENTAGES = ((_a = {})[INTERNAL_RESOLUTION_STRING_OPTIONS.low] = .25, _a[INTERNAL_RESOLUTION_STRING_OPTIONS.medium] = .5, _a[INTERNAL_RESOLUTION_STRING_OPTIONS.high] = .75, _a[INTERNAL_RESOLUTION_STRING_OPTIONS.full] = 1, _a),\n    MIN_INTERNAL_RESOLUTION = .1,\n    MAX_INTERNAL_RESOLUTION = 2;\n\nfunction toInternalResolutionPercentage(e) {\n  if (\"string\" == typeof e) {\n    var t = INTERNAL_RESOLUTION_PERCENTAGES[e];\n    return util.assert(\"number\" == typeof t, function () {\n      return \"string value of inputResolution must be one of \" + Object.values(INTERNAL_RESOLUTION_STRING_OPTIONS).join(\",\") + \" but was \" + e + \".\";\n    }), t;\n  }\n\n  return util.assert(\"number\" == typeof e && e <= MAX_INTERNAL_RESOLUTION && e >= MIN_INTERNAL_RESOLUTION, function () {\n    return \"inputResolution must be a string or number between \" + MIN_INTERNAL_RESOLUTION + \" and \" + MAX_INTERNAL_RESOLUTION + \", but was \" + e;\n  }), e;\n}\n\nfunction toInputResolutionHeightAndWidth(e, t, n) {\n  var r = n[0],\n      o = n[1],\n      i = toInternalResolutionPercentage(e);\n  return [toValidInputResolution(r * i, t), toValidInputResolution(o * i, t)];\n}\n\nfunction toInputTensor(e) {\n  return e instanceof Tensor ? e : browser.fromPixels(e);\n}\n\nfunction resizeAndPadTo(e, t, n) {\n  var r = t[0],\n      o = t[1];\n  void 0 === n && (n = !1);\n  var i,\n      a,\n      s,\n      d,\n      u,\n      l,\n      f = e.shape,\n      c = f[0],\n      p = f[1] / c;\n\n  if (p > o / r) {\n    i = o;\n    var h = r - (a = Math.ceil(i / p));\n    s = 0, d = 0, u = Math.floor(h / 2), l = r - (a + u);\n  } else {\n    a = r;\n    var m = o - (i = Math.ceil(r * p));\n    s = Math.floor(m / 2), d = o - (i + s), u = 0, l = 0;\n  }\n\n  return {\n    resizedAndPadded: tidy(function () {\n      var t;\n      return t = n ? image.resizeBilinear(reverse(e, 1), [a, i]) : image.resizeBilinear(e, [a, i]), pad3d(t, [[u, l], [s, d], [0, 0]]);\n    }),\n    paddedBy: [[u, l], [s, d]]\n  };\n}\n\nfunction scaleAndCropToInputTensorShape(e, t, n, r, o) {\n  var i = t[0],\n      a = t[1],\n      s = n[0],\n      d = n[1],\n      u = r[0],\n      l = u[0],\n      f = u[1],\n      c = r[1],\n      p = c[0],\n      h = c[1];\n  return void 0 === o && (o = !1), tidy(function () {\n    var t = image.resizeBilinear(e, [s, d], !0);\n    return o && (t = sigmoid(t)), removePaddingAndResizeBack(t, [i, a], [[l, f], [p, h]]);\n  });\n}\n\nfunction removePaddingAndResizeBack(e, t, n) {\n  var r = t[0],\n      o = t[1],\n      i = n[0],\n      a = i[0],\n      s = i[1],\n      d = n[1],\n      u = d[0],\n      l = d[1];\n  return tidy(function () {\n    var t = expandDims(e);\n    return squeeze(image.cropAndResize(t, [[a / (r + a + s - 1), u / (o + u + l - 1), (a + r - 1) / (r + a + s - 1), (u + o - 1) / (o + u + l - 1)]], [0], [r, o]), [0]);\n  });\n}\n\nfunction padAndResizeTo(e, t) {\n  var n = t[0],\n      r = t[1],\n      o = getInputSize(e),\n      i = o[0],\n      a = o[1],\n      s = r / n,\n      d = [0, 0, 0, 0],\n      u = d[0],\n      l = d[1],\n      f = d[2],\n      c = d[3];\n  return a / i < s ? (u = 0, l = 0, f = Math.round(.5 * (s * i - a)), c = Math.round(.5 * (s * i - a))) : (u = Math.round(.5 * (1 / s * a - i)), l = Math.round(.5 * (1 / s * a - i)), f = 0, c = 0), {\n    resized: tidy(function () {\n      var t = toInputTensor(e);\n      return t = pad3d(t, [[u, l], [f, c], [0, 0]]), image.resizeBilinear(t, [n, r]);\n    }),\n    padding: {\n      top: u,\n      left: f,\n      right: c,\n      bottom: l\n    }\n  };\n}\n\nfunction toTensorBuffers3D(e) {\n  return __awaiter(this, void 0, void 0, function () {\n    return __generator(this, function (t) {\n      return [2, Promise.all(e.map(function (e) {\n        return e.buffer();\n      }))];\n    });\n  });\n}\n\nfunction scalePose(e, t, n, r, o) {\n  return void 0 === r && (r = 0), void 0 === o && (o = 0), {\n    score: e.score,\n    keypoints: e.keypoints.map(function (e) {\n      var i = e.score,\n          a = e.part,\n          s = e.position;\n      return {\n        score: i,\n        part: a,\n        position: {\n          x: s.x * n + o,\n          y: s.y * t + r\n        }\n      };\n    })\n  };\n}\n\nfunction scalePoses(e, t, n, r, o) {\n  return void 0 === r && (r = 0), void 0 === o && (o = 0), 1 === n && 1 === t && 0 === r && 0 === o ? e : e.map(function (e) {\n    return scalePose(e, t, n, r, o);\n  });\n}\n\nfunction flipPoseHorizontal(e, t) {\n  return {\n    score: e.score,\n    keypoints: e.keypoints.map(function (e) {\n      var n = e.score,\n          r = e.part,\n          o = e.position;\n      return {\n        score: n,\n        part: r,\n        position: {\n          x: t - 1 - o.x,\n          y: o.y\n        }\n      };\n    })\n  };\n}\n\nfunction flipPosesHorizontal(e, t) {\n  return t <= 0 ? e : e.map(function (e) {\n    return flipPoseHorizontal(e, t);\n  });\n}\n\nfunction scaleAndFlipPoses(e, t, n, r, o) {\n  var i = t[0],\n      a = t[1],\n      s = n[0],\n      d = n[1],\n      u = scalePoses(e, (i + r.top + r.bottom) / s, (a + r.left + r.right) / d, -r.top, -r.left);\n  return o ? flipPosesHorizontal(u, a) : u;\n}\n\nvar APPLY_SIGMOID_ACTIVATION = !0,\n    FLIP_POSES_AFTER_SCALING = !1,\n    MOBILENET_V1_CONFIG = {\n  architecture: \"MobileNetV1\",\n  outputStride: 16,\n  quantBytes: 4,\n  multiplier: .75\n},\n    VALID_ARCHITECTURE = [\"MobileNetV1\", \"ResNet50\"],\n    VALID_STRIDE = {\n  MobileNetV1: [8, 16, 32],\n  ResNet50: [32, 16]\n},\n    VALID_MULTIPLIER = {\n  MobileNetV1: [.5, .75, 1],\n  ResNet50: [1]\n},\n    VALID_QUANT_BYTES = [1, 2, 4];\n\nfunction validateModelConfig(e) {\n  if (null == (e = e || MOBILENET_V1_CONFIG).architecture && (e.architecture = \"MobileNetV1\"), VALID_ARCHITECTURE.indexOf(e.architecture) < 0) throw new Error(\"Invalid architecture \" + e.architecture + \". Should be one of \" + VALID_ARCHITECTURE);\n  if (null == e.outputStride && (e.outputStride = 16), VALID_STRIDE[e.architecture].indexOf(e.outputStride) < 0) throw new Error(\"Invalid outputStride \" + e.outputStride + \". Should be one of \" + VALID_STRIDE[e.architecture] + \" for architecture \" + e.architecture + \".\");\n  if (null == e.multiplier && (e.multiplier = 1), VALID_MULTIPLIER[e.architecture].indexOf(e.multiplier) < 0) throw new Error(\"Invalid multiplier \" + e.multiplier + \". Should be one of \" + VALID_MULTIPLIER[e.architecture] + \" for architecture \" + e.architecture + \".\");\n  if (null == e.quantBytes && (e.quantBytes = 4), VALID_QUANT_BYTES.indexOf(e.quantBytes) < 0) throw new Error(\"Invalid quantBytes \" + e.quantBytes + \". Should be one of \" + VALID_QUANT_BYTES + \" for architecture \" + e.architecture + \".\");\n  return e;\n}\n\nvar PERSON_INFERENCE_CONFIG = {\n  flipHorizontal: !1,\n  internalResolution: \"medium\",\n  segmentationThreshold: .7,\n  maxDetections: 10,\n  scoreThreshold: .4,\n  nmsRadius: 20\n},\n    MULTI_PERSON_INSTANCE_INFERENCE_CONFIG = {\n  flipHorizontal: !1,\n  internalResolution: \"medium\",\n  segmentationThreshold: .7,\n  maxDetections: 10,\n  scoreThreshold: .4,\n  nmsRadius: 20,\n  minKeypointScore: .3,\n  refineSteps: 10\n};\n\nfunction validatePersonInferenceConfig(e) {\n  var t = e.segmentationThreshold,\n      n = e.maxDetections,\n      r = e.scoreThreshold,\n      o = e.nmsRadius;\n  if (t < 0 || t > 1) throw new Error(\"segmentationThreshold \" + t + \". Should be in range [0.0, 1.0]\");\n  if (n <= 0) throw new Error(\"Invalid maxDetections \" + n + \". Should be > 0\");\n  if (r < 0 || r > 1) throw new Error(\"Invalid scoreThreshold \" + r + \". Should be in range [0.0, 1.0]\");\n  if (o <= 0) throw new Error(\"Invalid nmsRadius \" + o + \".\");\n}\n\nfunction validateMultiPersonInstanceInferenceConfig(e) {\n  var t = e.segmentationThreshold,\n      n = e.maxDetections,\n      r = e.scoreThreshold,\n      o = e.nmsRadius,\n      i = e.minKeypointScore,\n      a = e.refineSteps;\n  if (t < 0 || t > 1) throw new Error(\"segmentationThreshold \" + t + \". Should be in range [0.0, 1.0]\");\n  if (n <= 0) throw new Error(\"Invalid maxDetections \" + n + \". Should be > 0\");\n  if (r < 0 || r > 1) throw new Error(\"Invalid scoreThreshold \" + r + \". Should be in range [0.0, 1.0]\");\n  if (o <= 0) throw new Error(\"Invalid nmsRadius \" + o + \".\");\n  if (i < 0 || i > 1) throw new Error(\"Invalid minKeypointScore \" + i + \".Should be in range [0.0, 1.0]\");\n  if (a <= 0 || a > 20) throw new Error(\"Invalid refineSteps \" + a + \".Should be in range [1, 20]\");\n}\n\nvar BodyPix = function () {\n  function e(e) {\n    this.baseModel = e;\n  }\n\n  return e.prototype.predictForPersonSegmentation = function (e) {\n    var t = this.baseModel.predict(e);\n    return {\n      segmentLogits: t.segmentation,\n      heatmapScores: t.heatmapScores,\n      offsets: t.offsets,\n      displacementFwd: t.displacementFwd,\n      displacementBwd: t.displacementBwd\n    };\n  }, e.prototype.predictForPersonSegmentationAndPart = function (e) {\n    var t = this.baseModel.predict(e);\n    return {\n      segmentLogits: t.segmentation,\n      partHeatmapLogits: t.partHeatmaps,\n      heatmapScores: t.heatmapScores,\n      offsets: t.offsets,\n      displacementFwd: t.displacementFwd,\n      displacementBwd: t.displacementBwd\n    };\n  }, e.prototype.predictForMultiPersonInstanceSegmentationAndPart = function (e) {\n    var t = this.baseModel.predict(e);\n    return {\n      segmentLogits: t.segmentation,\n      longOffsets: t.longOffsets,\n      heatmapScores: t.heatmapScores,\n      offsets: t.offsets,\n      displacementFwd: t.displacementFwd,\n      displacementBwd: t.displacementBwd,\n      partHeatmaps: t.partHeatmaps\n    };\n  }, e.prototype.segmentPersonActivation = function (e, t, n) {\n    var r = this;\n    void 0 === n && (n = .5);\n    var o = getInputSize(e),\n        i = o[0],\n        a = o[1],\n        s = toInputResolutionHeightAndWidth(t, this.baseModel.outputStride, [i, a]),\n        d = padAndResizeTo(e, s),\n        u = d.resized,\n        l = d.padding,\n        f = tidy(function () {\n      var e = r.predictForPersonSegmentation(u),\n          t = e.segmentLogits,\n          o = e.heatmapScores,\n          s = e.offsets,\n          d = e.displacementFwd,\n          f = e.displacementBwd,\n          c = u.shape,\n          p = c[0],\n          h = c[1],\n          m = scaleAndCropToInputTensorShape(t, [i, a], [p, h], [[l.top, l.bottom], [l.left, l.right]], APPLY_SIGMOID_ACTIVATION);\n      return {\n        segmentation: toMaskTensor(squeeze(m), n),\n        heatmapScores: o,\n        offsets: s,\n        displacementFwd: d,\n        displacementBwd: f\n      };\n    }),\n        c = f.segmentation,\n        p = f.heatmapScores,\n        h = f.offsets,\n        m = f.displacementFwd,\n        g = f.displacementBwd;\n    return u.dispose(), {\n      segmentation: c,\n      heatmapScores: p,\n      offsets: h,\n      displacementFwd: m,\n      displacementBwd: g,\n      padding: l,\n      internalResolutionHeightAndWidth: s\n    };\n  }, e.prototype.segmentPerson = function (e, t) {\n    return void 0 === t && (t = PERSON_INFERENCE_CONFIG), __awaiter(this, void 0, void 0, function () {\n      var n, r, o, i, a, s, d, u, l, f, c, p, h, m, g, v, S, _;\n\n      return __generator(this, function (I) {\n        switch (I.label) {\n          case 0:\n            return validatePersonInferenceConfig(t = __assign({}, PERSON_INFERENCE_CONFIG, t)), n = this.segmentPersonActivation(e, t.internalResolution, t.segmentationThreshold), r = n.segmentation, o = n.heatmapScores, i = n.offsets, a = n.displacementFwd, s = n.displacementBwd, d = n.padding, u = n.internalResolutionHeightAndWidth, l = r.shape, f = l[0], c = l[1], [4, r.data()];\n\n          case 1:\n            return p = I.sent(), r.dispose(), [4, toTensorBuffers3D([o, i, a, s])];\n\n          case 2:\n            return h = I.sent(), m = h[0], g = h[1], v = h[2], S = h[3], _ = scaleAndFlipPoses(_ = decodeMultiplePoses(m, g, v, S, this.baseModel.outputStride, t.maxDetections, t.scoreThreshold, t.nmsRadius), [f, c], u, d, FLIP_POSES_AFTER_SCALING), o.dispose(), i.dispose(), a.dispose(), s.dispose(), [2, {\n              height: f,\n              width: c,\n              data: p,\n              allPoses: _\n            }];\n        }\n      });\n    });\n  }, e.prototype.segmentMultiPerson = function (e, t) {\n    return void 0 === t && (t = MULTI_PERSON_INSTANCE_INFERENCE_CONFIG), __awaiter(this, void 0, void 0, function () {\n      var n,\n          r,\n          o,\n          i,\n          a,\n          s,\n          d,\n          u,\n          l,\n          f,\n          c,\n          p,\n          h,\n          m,\n          g,\n          v,\n          S,\n          _,\n          I,\n          w,\n          E,\n          T = this;\n\n      return __generator(this, function (N) {\n        switch (N.label) {\n          case 0:\n            return validateMultiPersonInstanceInferenceConfig(t = __assign({}, MULTI_PERSON_INSTANCE_INFERENCE_CONFIG, t)), n = getInputSize(e), r = n[0], o = n[1], i = toInputResolutionHeightAndWidth(t.internalResolution, this.baseModel.outputStride, [r, o]), a = padAndResizeTo(e, i), s = a.resized, d = a.padding, u = tidy(function () {\n              var e,\n                  n = T.predictForMultiPersonInstanceSegmentationAndPart(s),\n                  a = n.segmentLogits,\n                  u = n.longOffsets,\n                  l = n.heatmapScores,\n                  f = n.offsets,\n                  c = n.displacementFwd,\n                  p = n.displacementBwd,\n                  h = scaleAndCropToInputTensorShape(a, [r, o], i, [[d.top, d.bottom], [d.left, d.right]], APPLY_SIGMOID_ACTIVATION);\n              return e = u, {\n                segmentation: toMaskTensor(squeeze(h), t.segmentationThreshold),\n                longOffsets: e,\n                heatmapScoresRaw: l,\n                offsetsRaw: f,\n                displacementFwdRaw: c,\n                displacementBwdRaw: p\n              };\n            }), l = u.segmentation, f = u.longOffsets, c = u.heatmapScoresRaw, p = u.offsetsRaw, h = u.displacementFwdRaw, m = u.displacementBwdRaw, [4, toTensorBuffers3D([c, p, h, m])];\n\n          case 1:\n            return g = N.sent(), v = g[0], S = g[1], _ = g[2], I = g[3], w = scaleAndFlipPoses(w = decodeMultiplePoses(v, S, _, I, this.baseModel.outputStride, t.maxDetections, t.scoreThreshold, t.nmsRadius), [r, o], i, d, FLIP_POSES_AFTER_SCALING), [4, decodePersonInstanceMasks(l, f, w, r, o, this.baseModel.outputStride, i, d, t.scoreThreshold, t.refineSteps, t.minKeypointScore, t.maxDetections)];\n\n          case 2:\n            return E = N.sent(), s.dispose(), l.dispose(), f.dispose(), c.dispose(), p.dispose(), h.dispose(), m.dispose(), [2, E];\n        }\n      });\n    });\n  }, e.prototype.segmentPersonPartsActivation = function (e, t, n) {\n    var r = this;\n    void 0 === n && (n = .5);\n    var o = getInputSize(e),\n        i = o[0],\n        a = o[1],\n        s = toInputResolutionHeightAndWidth(t, this.baseModel.outputStride, [i, a]),\n        d = padAndResizeTo(e, s),\n        u = d.resized,\n        l = d.padding,\n        f = tidy(function () {\n      var e = r.predictForPersonSegmentationAndPart(u),\n          t = e.segmentLogits,\n          o = e.partHeatmapLogits,\n          s = e.heatmapScores,\n          d = e.offsets,\n          f = e.displacementFwd,\n          c = e.displacementBwd,\n          p = u.shape,\n          h = p[0],\n          m = p[1],\n          g = scaleAndCropToInputTensorShape(t, [i, a], [h, m], [[l.top, l.bottom], [l.left, l.right]], APPLY_SIGMOID_ACTIVATION),\n          v = scaleAndCropToInputTensorShape(o, [i, a], [h, m], [[l.top, l.bottom], [l.left, l.right]], APPLY_SIGMOID_ACTIVATION);\n      return {\n        partSegmentation: decodePartSegmentation(toMaskTensor(squeeze(g), n), v),\n        heatmapScores: s,\n        offsets: d,\n        displacementFwd: f,\n        displacementBwd: c\n      };\n    }),\n        c = f.partSegmentation,\n        p = f.heatmapScores,\n        h = f.offsets,\n        m = f.displacementFwd,\n        g = f.displacementBwd;\n    return u.dispose(), {\n      partSegmentation: c,\n      heatmapScores: p,\n      offsets: h,\n      displacementFwd: m,\n      displacementBwd: g,\n      padding: l,\n      internalResolutionHeightAndWidth: s\n    };\n  }, e.prototype.segmentPersonParts = function (e, t) {\n    return void 0 === t && (t = PERSON_INFERENCE_CONFIG), __awaiter(this, void 0, void 0, function () {\n      var n, r, o, i, a, s, d, u, l, f, c, p, h, m, g, v, S, _;\n\n      return __generator(this, function (I) {\n        switch (I.label) {\n          case 0:\n            return validatePersonInferenceConfig(t = __assign({}, PERSON_INFERENCE_CONFIG, t)), n = this.segmentPersonPartsActivation(e, t.internalResolution, t.segmentationThreshold), r = n.partSegmentation, o = n.heatmapScores, i = n.offsets, a = n.displacementFwd, s = n.displacementBwd, d = n.padding, u = n.internalResolutionHeightAndWidth, l = r.shape, f = l[0], c = l[1], [4, r.data()];\n\n          case 1:\n            return p = I.sent(), r.dispose(), [4, toTensorBuffers3D([o, i, a, s])];\n\n          case 2:\n            return h = I.sent(), m = h[0], g = h[1], v = h[2], S = h[3], _ = scaleAndFlipPoses(_ = decodeMultiplePoses(m, g, v, S, this.baseModel.outputStride, t.maxDetections, t.scoreThreshold, t.nmsRadius), [f, c], u, d, FLIP_POSES_AFTER_SCALING), o.dispose(), i.dispose(), a.dispose(), s.dispose(), [2, {\n              height: f,\n              width: c,\n              data: p,\n              allPoses: _\n            }];\n        }\n      });\n    });\n  }, e.prototype.segmentMultiPersonParts = function (e, t) {\n    return void 0 === t && (t = MULTI_PERSON_INSTANCE_INFERENCE_CONFIG), __awaiter(this, void 0, void 0, function () {\n      var n,\n          r,\n          o,\n          i,\n          a,\n          s,\n          d,\n          u,\n          l,\n          f,\n          c,\n          p,\n          h,\n          m,\n          g,\n          v,\n          S,\n          _,\n          I,\n          w,\n          E,\n          T,\n          N = this;\n\n      return __generator(this, function (A) {\n        switch (A.label) {\n          case 0:\n            return validateMultiPersonInstanceInferenceConfig(t = __assign({}, MULTI_PERSON_INSTANCE_INFERENCE_CONFIG, t)), n = getInputSize(e), r = n[0], o = n[1], i = toInputResolutionHeightAndWidth(t.internalResolution, this.baseModel.outputStride, [r, o]), a = padAndResizeTo(e, i), s = a.resized, d = a.padding, u = tidy(function () {\n              var e = N.predictForMultiPersonInstanceSegmentationAndPart(s),\n                  n = e.segmentLogits,\n                  a = e.longOffsets,\n                  u = e.heatmapScores,\n                  l = e.offsets,\n                  f = e.displacementFwd,\n                  c = e.displacementBwd,\n                  p = e.partHeatmaps,\n                  h = scaleAndCropToInputTensorShape(n, [r, o], i, [[d.top, d.bottom], [d.left, d.right]], APPLY_SIGMOID_ACTIVATION),\n                  m = scaleAndCropToInputTensorShape(p, [r, o], i, [[d.top, d.bottom], [d.left, d.right]], APPLY_SIGMOID_ACTIVATION),\n                  g = a;\n              return {\n                segmentation: toMaskTensor(squeeze(h), t.segmentationThreshold),\n                longOffsets: g,\n                heatmapScoresRaw: u,\n                offsetsRaw: l,\n                displacementFwdRaw: f,\n                displacementBwdRaw: c,\n                partSegmentation: decodeOnlyPartSegmentation(m)\n              };\n            }), l = u.segmentation, f = u.longOffsets, c = u.heatmapScoresRaw, p = u.offsetsRaw, h = u.displacementFwdRaw, m = u.displacementBwdRaw, g = u.partSegmentation, [4, toTensorBuffers3D([c, p, h, m])];\n\n          case 1:\n            return v = A.sent(), S = v[0], _ = v[1], I = v[2], w = v[3], E = scaleAndFlipPoses(E = decodeMultiplePoses(S, _, I, w, this.baseModel.outputStride, t.maxDetections, t.scoreThreshold, t.nmsRadius), [r, o], i, d, FLIP_POSES_AFTER_SCALING), [4, decodePersonInstancePartMasks(l, f, g, E, r, o, this.baseModel.outputStride, i, d, t.scoreThreshold, t.refineSteps, t.minKeypointScore, t.maxDetections)];\n\n          case 2:\n            return T = A.sent(), s.dispose(), l.dispose(), f.dispose(), c.dispose(), p.dispose(), h.dispose(), m.dispose(), g.dispose(), [2, T];\n        }\n      });\n    });\n  }, e.prototype.dispose = function () {\n    this.baseModel.dispose();\n  }, e;\n}();\n\nfunction loadMobileNet(e) {\n  return __awaiter(this, void 0, void 0, function () {\n    var t, n, r, o, i, a;\n    return __generator(this, function (s) {\n      switch (s.label) {\n        case 0:\n          if (t = e.outputStride, n = e.quantBytes, r = e.multiplier, null == tf) throw new Error(\"Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this\\n        model.\");\n          return o = mobileNetSavedModel(t, r, n), [4, loadGraphModel(e.modelUrl || o)];\n\n        case 1:\n          return i = s.sent(), a = new MobileNet(i, t), [2, new BodyPix(a)];\n      }\n    });\n  });\n}\n\nfunction loadResNet(e) {\n  return __awaiter(this, void 0, void 0, function () {\n    var t, n, r, o, i;\n    return __generator(this, function (a) {\n      switch (a.label) {\n        case 0:\n          if (t = e.outputStride, n = e.quantBytes, null == tf) throw new Error(\"Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this\\n        model.\");\n          return r = resNet50SavedModel(t, n), [4, loadGraphModel(e.modelUrl || r)];\n\n        case 1:\n          return o = a.sent(), i = new ResNet(o, t), [2, new BodyPix(i)];\n      }\n    });\n  });\n}\n\nfunction load(e) {\n  return void 0 === e && (e = MOBILENET_V1_CONFIG), __awaiter(this, void 0, void 0, function () {\n    return __generator(this, function (t) {\n      return \"ResNet50\" === (e = validateModelConfig(e)).architecture ? [2, loadResNet(e)] : \"MobileNetV1\" === e.architecture ? [2, loadMobileNet(e)] : [2, null];\n    });\n  });\n}\n\nfunction cpuBlur(e, t, n) {\n  for (var r = e.getContext(\"2d\"), o = 0, i = 1 / (2 * Math.PI * 5 * 5), a = n < 3 ? 1 : 2, s = -n; s <= n; s += a) for (var d = -n; d <= n; d += a) {\n    o += i * Math.exp(-(d * d + s * s) / 50);\n  }\n\n  for (s = -n; s <= n; s += a) for (d = -n; d <= n; d += a) r.globalAlpha = i * Math.exp(-(d * d + s * s) / 50) / o * n, r.drawImage(t, d, s);\n\n  r.globalAlpha = 1;\n}\n\nvar offScreenCanvases = {};\n\nfunction isSafari() {\n  return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n}\n\nfunction assertSameDimensions(e, t, n, r) {\n  var o = e.width,\n      i = e.height,\n      a = t.width,\n      s = t.height;\n  if (o !== a || i !== s) throw new Error(\"error: dimensions must match. \" + n + \" has dimensions \" + o + \"x\" + i + \", \" + r + \" has dimensions \" + a + \"x\" + s);\n}\n\nfunction flipCanvasHorizontal(e) {\n  var t = e.getContext(\"2d\");\n  t.scale(-1, 1), t.translate(-e.width, 0);\n}\n\nfunction drawWithCompositing(e, t, n) {\n  e.globalCompositeOperation = n, e.drawImage(t, 0, 0);\n}\n\nfunction createOffScreenCanvas() {\n  return document.createElement(\"canvas\");\n}\n\nfunction ensureOffscreenCanvasCreated(e) {\n  return offScreenCanvases[e] || (offScreenCanvases[e] = createOffScreenCanvas()), offScreenCanvases[e];\n}\n\nfunction drawAndBlurImageOnCanvas(e, t, n) {\n  var r = e.height,\n      o = e.width,\n      i = n.getContext(\"2d\");\n  n.width = o, n.height = r, i.clearRect(0, 0, o, r), i.save(), isSafari() ? cpuBlur(n, e, t) : (i.filter = \"blur(\" + t + \"px)\", i.drawImage(e, 0, 0, o, r)), i.restore();\n}\n\nfunction drawAndBlurImageOnOffScreenCanvas(e, t, n) {\n  var r = ensureOffscreenCanvasCreated(n);\n  return 0 === t ? renderImageToCanvas(e, r) : drawAndBlurImageOnCanvas(e, t, r), r;\n}\n\nfunction renderImageToCanvas(e, t) {\n  var n = e.width,\n      r = e.height;\n  t.width = n, t.height = r, t.getContext(\"2d\").drawImage(e, 0, 0, n, r);\n}\n\nfunction renderImageDataToCanvas(e, t) {\n  t.width = e.width, t.height = e.height, t.getContext(\"2d\").putImageData(e, 0, 0);\n}\n\nfunction renderImageDataToOffScreenCanvas(e, t) {\n  var n = ensureOffscreenCanvasCreated(t);\n  return renderImageDataToCanvas(e, n), n;\n}\n\nfunction toMask(e, t, n, r, o) {\n  if (void 0 === t && (t = {\n    r: 0,\n    g: 0,\n    b: 0,\n    a: 0\n  }), void 0 === n && (n = {\n    r: 0,\n    g: 0,\n    b: 0,\n    a: 255\n  }), void 0 === r && (r = !1), void 0 === o && (o = [1]), Array.isArray(e) && 0 === e.length) return null;\n  var i,\n      a = (i = Array.isArray(e) ? e : [e])[0],\n      s = a.width,\n      d = a.height,\n      u = new Uint8ClampedArray(s * d * 4);\n\n  function l(e, t, n, r, o, i) {\n    void 0 === i && (i = {\n      r: 0,\n      g: 255,\n      b: 255,\n      a: 255\n    });\n\n    for (var a = -o; a <= o; a++) for (var s = -o; s <= o; s++) if (0 !== a && 0 !== s) {\n      var d = (t + a) * r + (n + s);\n      e[4 * d + 0] = i.r, e[4 * d + 1] = i.g, e[4 * d + 2] = i.b, e[4 * d + 3] = i.a;\n    }\n  }\n\n  function f(e, t, n, r, o, i) {\n    void 0 === o && (o = [1]), void 0 === i && (i = 1);\n\n    for (var a = 0, s = -i; s <= i; s++) for (var d = function (i) {\n      if (0 !== s && 0 !== i) {\n        var d = (t + s) * r + (n + i);\n        o.some(function (t) {\n          return t === e[d];\n        }) || (a += 1);\n      }\n    }, u = -i; u <= i; u++) d(u);\n\n    return a > 0;\n  }\n\n  for (var c = 0; c < d; c += 1) for (var p = function (e) {\n    var a = c * s + e;\n    u[4 * a + 0] = n.r, u[4 * a + 1] = n.g, u[4 * a + 2] = n.b, u[4 * a + 3] = n.a;\n\n    for (var p = function (n) {\n      if (o.some(function (e) {\n        return e === i[n].data[a];\n      })) {\n        u[4 * a] = t.r, u[4 * a + 1] = t.g, u[4 * a + 2] = t.b, u[4 * a + 3] = t.a;\n        var p = f(i[n].data, c, e, s, o);\n        r && c - 1 >= 0 && c + 1 < d && e - 1 >= 0 && e + 1 < s && p && l(u, c, e, s, 1);\n      }\n    }, h = 0; h < i.length; h++) p(h);\n  }, h = 0; h < s; h += 1) p(h);\n\n  return new ImageData(u, s, d);\n}\n\nvar RAINBOW_PART_COLORS = [[110, 64, 170], [143, 61, 178], [178, 60, 178], [210, 62, 167], [238, 67, 149], [255, 78, 125], [255, 94, 99], [255, 115, 75], [255, 140, 56], [239, 167, 47], [217, 194, 49], [194, 219, 64], [175, 240, 91], [135, 245, 87], [96, 247, 96], [64, 243, 115], [40, 234, 141], [28, 219, 169], [26, 199, 194], [33, 176, 213], [47, 150, 224], [65, 125, 224], [84, 101, 214], [99, 81, 195]];\n\nfunction toColoredPartMask(e, t) {\n  if (void 0 === t && (t = RAINBOW_PART_COLORS), Array.isArray(e) && 0 === e.length) return null;\n\n  for (var n, r = (n = Array.isArray(e) ? e : [e])[0], o = r.width, i = r.height, a = new Uint8ClampedArray(o * i * 4), s = 0; s < i * o; ++s) {\n    var d = 4 * s;\n    a[d + 0] = 255, a[d + 1] = 255, a[d + 2] = 255, a[d + 3] = 255;\n\n    for (var u = 0; u < n.length; u++) {\n      var l = n[u].data[s];\n\n      if (-1 !== l) {\n        var f = t[l];\n        if (!f) throw new Error(\"No color could be found for part id \" + l);\n        a[d + 0] = f[0], a[d + 1] = f[1], a[d + 2] = f[2], a[d + 3] = 255;\n      }\n    }\n  }\n\n  return new ImageData(a, o, i);\n}\n\nvar CANVAS_NAMES = {\n  blurred: \"blurred\",\n  blurredMask: \"blurred-mask\",\n  mask: \"mask\",\n  lowresPartMask: \"lowres-part-mask\"\n};\n\nfunction drawMask(e, t, n, r, o, i) {\n  void 0 === r && (r = .7), void 0 === o && (o = 0), void 0 === i && (i = !1);\n  var a = getInputSize(t),\n      s = a[0],\n      d = a[1];\n  e.width = d, e.height = s;\n  var u = e.getContext(\"2d\");\n\n  if (u.save(), i && flipCanvasHorizontal(e), u.drawImage(t, 0, 0), u.globalAlpha = r, n) {\n    assertSameDimensions({\n      width: d,\n      height: s\n    }, n, \"image\", \"mask\");\n    var l = drawAndBlurImageOnOffScreenCanvas(renderImageDataToOffScreenCanvas(n, CANVAS_NAMES.mask), o, CANVAS_NAMES.blurredMask);\n    u.drawImage(l, 0, 0, d, s);\n  }\n\n  u.restore();\n}\n\nfunction drawPixelatedMask(e, t, n, r, o, i, a) {\n  void 0 === r && (r = .7), void 0 === o && (o = 0), void 0 === i && (i = !1), void 0 === a && (a = 10);\n  var s = getInputSize(t),\n      d = s[0];\n  assertSameDimensions({\n    width: s[1],\n    height: d\n  }, n, \"image\", \"mask\");\n  var u = drawAndBlurImageOnOffScreenCanvas(renderImageDataToOffScreenCanvas(n, CANVAS_NAMES.mask), o, CANVAS_NAMES.blurredMask);\n  e.width = u.width, e.height = u.height;\n  var l = e.getContext(\"2d\");\n  l.save(), i && flipCanvasHorizontal(e);\n  var f = ensureOffscreenCanvasCreated(CANVAS_NAMES.lowresPartMask),\n      c = f.getContext(\"2d\");\n  f.width = u.width * (1 / a), f.height = u.height * (1 / a), c.drawImage(u, 0, 0, u.width, u.height, 0, 0, f.width, f.height), l.imageSmoothingEnabled = !1, l.drawImage(f, 0, 0, f.width, f.height, 0, 0, e.width, e.height);\n\n  for (var p = 0; p < f.width; p++) l.beginPath(), l.strokeStyle = \"#ffffff\", l.moveTo(a * p, 0), l.lineTo(a * p, e.height), l.stroke();\n\n  for (p = 0; p < f.height; p++) l.beginPath(), l.strokeStyle = \"#ffffff\", l.moveTo(0, a * p), l.lineTo(e.width, a * p), l.stroke();\n\n  l.globalAlpha = 1 - r, l.drawImage(t, 0, 0, u.width, u.height), l.restore();\n}\n\nfunction createPersonMask(e, t) {\n  var n = renderImageDataToOffScreenCanvas(toMask(e, {\n    r: 0,\n    g: 0,\n    b: 0,\n    a: 255\n  }, {\n    r: 0,\n    g: 0,\n    b: 0,\n    a: 0\n  }), CANVAS_NAMES.mask);\n  return 0 === t ? n : drawAndBlurImageOnOffScreenCanvas(n, t, CANVAS_NAMES.blurredMask);\n}\n\nfunction drawBokehEffect(e, t, n, r, o, i) {\n  void 0 === r && (r = 3), void 0 === o && (o = 3), void 0 === i && (i = !1);\n  var a = drawAndBlurImageOnOffScreenCanvas(t, r, CANVAS_NAMES.blurred);\n  e.width = a.width, e.height = a.height;\n  var s = e.getContext(\"2d\");\n  if (Array.isArray(n) && 0 === n.length) s.drawImage(a, 0, 0);else {\n    var d = createPersonMask(n, o);\n    s.save(), i && flipCanvasHorizontal(e);\n    var u = getInputSize(t),\n        l = u[0],\n        f = u[1];\n    s.drawImage(t, 0, 0, f, l), drawWithCompositing(s, d, \"destination-in\"), drawWithCompositing(s, a, \"destination-over\"), s.restore();\n  }\n}\n\nfunction createBodyPartMask(e, t, n) {\n  var r = renderImageDataToOffScreenCanvas(toMask(e, {\n    r: 0,\n    g: 0,\n    b: 0,\n    a: 0\n  }, {\n    r: 0,\n    g: 0,\n    b: 0,\n    a: 255\n  }, !0, t), CANVAS_NAMES.mask);\n  return 0 === n ? r : drawAndBlurImageOnOffScreenCanvas(r, n, CANVAS_NAMES.blurredMask);\n}\n\nfunction blurBodyPart(e, t, n, r, o, i, a) {\n  void 0 === r && (r = [0, 1]), void 0 === o && (o = 3), void 0 === i && (i = 3), void 0 === a && (a = !1);\n  var s = drawAndBlurImageOnOffScreenCanvas(t, o, CANVAS_NAMES.blurred);\n  e.width = s.width, e.height = s.height;\n  var d = e.getContext(\"2d\");\n  if (Array.isArray(n) && 0 === n.length) d.drawImage(s, 0, 0);else {\n    var u = createBodyPartMask(n, r, i);\n    d.save(), a && flipCanvasHorizontal(e);\n    var l = getInputSize(t),\n        f = l[0],\n        c = l[1];\n    d.drawImage(t, 0, 0, c, f), drawWithCompositing(d, u, \"destination-in\"), drawWithCompositing(d, s, \"destination-over\"), d.restore();\n  }\n}\n\nvar PART_CHANNELS = [\"left_face\", \"right_face\", \"left_upper_arm_front\", \"left_upper_arm_back\", \"right_upper_arm_front\", \"right_upper_arm_back\", \"left_lower_arm_front\", \"left_lower_arm_back\", \"right_lower_arm_front\", \"right_lower_arm_back\", \"left_hand\", \"right_hand\", \"torso_front\", \"torso_back\", \"left_upper_leg_front\", \"left_upper_leg_back\", \"right_upper_leg_front\", \"right_upper_leg_back\", \"left_lower_leg_front\", \"left_lower_leg_back\", \"right_lower_leg_front\", \"right_lower_leg_back\", \"left_feet\", \"right_feet\"],\n    version = \"2.1.0\";\nexport { BodyPix, load, blurBodyPart, drawBokehEffect, drawMask, drawPixelatedMask, toColoredPartMask, toMask, PART_CHANNELS, flipPoseHorizontal, resizeAndPadTo, scaleAndCropToInputTensorShape, version };","map":{"version":3,"sources":["../src/decode_part_map.ts","../src/base_model.ts","../src/mobilenet.ts","../src/keypoints.ts","../src/multi_person/util.ts","../src/multi_person/decode_multiple_masks_cpu.ts","../src/multi_person/decode_multiple_masks_webgl.ts","../src/multi_person/decode_instance_masks.ts","../src/multi_person/max_heap.ts","../src/multi_person/build_part_with_score_queue.ts","../src/multi_person/decode_pose.ts","../src/multi_person/decode_multiple_poses.ts","../src/resnet.ts","../src/saved_models.ts","../src/util.ts","../src/body_pix_model.ts","../src/blur.ts","../src/output_rendering_util.ts","../src/part_channels.ts","../src/version.ts"],"names":["toFlattenedOneHotPartMap","partHeatmapScores","numParts","shape","partMapLocations","tf.argMax","partMapFlattened","tf.reshape","tf.oneHot","clipByMask2d","image","mask","tf.mul","toMaskTensor","segmentScores","threshold","tf.tidy","tf.cast","tf.greater","tf.scalar","decodePartSegmentation","segmentationMask","partMapHeight","partMapWidth","flattenedMap","partNumbers","tf.expandDims","tf.range","tf.matMul","partMap","partMapShiftedUpForClipping","tf.add","tf.sub","decodeOnlyPartSegmentation","model","outputStride","inputShape","this","inputs","tf.util","assert","BaseModel","input","asFloat","_this","preprocessInput","asBatch","predict","results3d","map","y","namedResults","nameOutputResults","heatmapScores","tf.sigmoid","heatmap","offsets","displacementFwd","displacementBwd","segmentation","partHeatmaps","longOffsets","partOffsets","dispose","tslib_1.__extends","MobileNet","tf.div","results","PART_NAMES","NUM_KEYPOINTS","length","PART_IDS","reduce","result","jointName","i","CONNECTED_PART_NAMES","POSE_CHAIN","CONNECTED_PART_INDICES","_a","jointNameA","jointNameB","getScale","height","width","_b","inputResolutionY","inputResolutionX","padding","padT","padB","getOffsetPoint","x","keypoint","get","getImageCoords","part","heatmapX","heatmapY","clamp","a","min","max","squaredDistance","y1","x1","y2","x2","dy","dx","addVectors","b","computeDistance","embedding","pose","minPartScore","distance","numKpt","p","keypoints","score","Math","position","Infinity","convertToPositionInOuput","padL","scaleX","scaleY","stride","round","getEmbedding","location","keypointIndex","convertToPosition","outputResolutionX","refineSteps","newLocation","nn","t","newPos","nn_1","matchEmbeddingToInstance","poses","numKptForMatching","_c","embed","pair","keypointsIndex","push","kMin","kMinDist","k","dist","getOutputResolution","decodeMultipleMasksCPU","posesAboveScore","inHeight","inWidth","dataArrays","Uint8Array","fill","j","n","decodeMultiplePartMasksCPU","partSegmentaion","Int32Array","decodeMultipleMasksWebGl","minKptScore","maxNumPeople","origHeight","origWidth","outHeight","outWidth","shapedLongOffsets","poseVals","Float32Array","poseOffset","kp","offset","posesTensor","tf.tensor","program","variableNames","outputShape","userCode","tf.backend","compileAndRun","toPersonKSegmentation","tf.equal","toPersonKPartSegmentation","bodyParts","isWebGlBackend","getBackend","decodePersonInstanceMasks","minPoseScore","minKeypointScore","filter","personSegmentations","masksTensorInfo","masksTensor","tf.engine","makeTensorFromDataId","dataId","dtype","_","personSegmentationsData","Promise","all","data","forEach","segmentationsData","longOffsetsData","decodePersonInstancePartMasks","partSegmentation","partSegmentations","partSegmentationsByPersonData","partSegmentaionData","half","floor","maxSize","getElementValue","priorityQueue","Array","numberOfElements","MaxHeap","swim","exchange","sink","slice","less","getValueAt","scoreIsMaximumInLocalWindow","keypointId","localMaximumRadius","scores","localMaximum","yStart","yEnd","yCurrent","xStart","xEnd","xCurrent","buildPartWithScoreQueue","scoreThreshold","numKeypoints","queue","enqueue","id","parentChildrenTuples","parentJoinName","childJoinName","parentToChildEdges","childToParentEdges","getDisplacement","edgeId","point","displacements","numEdges","getStridedIndexNearPoint","traverseToTargetKeypoint","sourceKeypoint","targetKeypointId","scoresBuffer","offsetRefineStep","displacement","targetKeypoint","targetKeypointIndices","offsetPoint","targetKeyPointIndices","decodePose","root","displacementsFwd","displacementsBwd","instanceKeypoints","rootPart","rootScore","rootPoint","edge","sourceKeypointId","withinNmsRadiusOfCorrespondingPoint","squaredNmsRadius","some","correspondingKeypoint","getInstanceScore","existingPoses","kLocalMaximumRadius","decodeMultiplePoses","offsetsBuffer","displacementsFwdBuffer","displacementsBwdBuffer","maxPoseDetections","nmsRadius","empty","dequeue","imageNetMean","ResNet","RESNET50_BASE_URL","MOBILENET_BASE_URL","resNet50SavedModel","quantBytes","graphJson","mobileNetSavedModel","multiplier","toStr","1","0.75","0.5","getSizeFromImageLikeElement","offsetHeight","offsetWidth","Error","getSizeFromVideoElement","hasAttribute","videoHeight","videoWidth","getInputSize","HTMLCanvasElement","HTMLImageElement","ImageData","HTMLVideoElement","tf.Tensor","isValidInputResolution","resolution","toValidInputResolution","inputResolution","INTERNAL_RESOLUTION_STRING_OPTIONS","low","medium","high","full","INTERNAL_RESOLUTION_PERCENTAGES","MIN_INTERNAL_RESOLUTION","MAX_INTERNAL_RESOLUTION","toInternalResolutionPercentage","internalResolution","Object","values","join","toInputResolutionHeightAndWidth","inputHeight","inputWidth","internalResolutionPercentage","toInputTensor","tf.browser","fromPixels","resizeAndPadTo","imageTensor","targetH","targetW","flipHorizontal","aspect","resizeW","resizeH","padR","ceil","padHeight","padWidth","resized","tf.image","resizeBilinear","tf.reverse","tf.pad3d","resizedAndPadded","paddedBy","scaleAndCropToInputTensorShape","tensor","inputTensorHeight","inputTensorWidth","resizedAndPaddedHeight","resizedAndPaddedWidth","_d","_e","applySigmoidActivation","inResizedAndPadded","removePaddingAndResizeBack","originalHeight","originalWidth","batchedImage","tf.squeeze","cropAndResize","padAndResizeTo","targetAspect","top","left","right","bottom","toTensorBuffers3D","tensors","buffer","scalePose","offsetY","offsetX","scalePoses","flipPoseHorizontal","imageWidth","flipPosesHorizontal","scaleAndFlipPoses","inputResolutionHeight","inputResolutionWidth","scaledPoses","APPLY_SIGMOID_ACTIVATION","FLIP_POSES_AFTER_SCALING","MOBILENET_V1_CONFIG","architecture","VALID_ARCHITECTURE","VALID_STRIDE","MobileNetV1","ResNet50","VALID_MULTIPLIER","VALID_QUANT_BYTES","validateModelConfig","config","indexOf","PERSON_INFERENCE_CONFIG","segmentationThreshold","maxDetections","MULTI_PERSON_INSTANCE_INFERENCE_CONFIG","validatePersonInferenceConfig","validateMultiPersonInstanceInferenceConfig","net","baseModel","BodyPix","segmentLogits","partHeatmapLogits","internalResolutionHeightAndWidth","segmentPersonActivation","tensorBuffers","scoresBuf","offsetsBuf","displacementsFwdBuf","displacementsBwdBuf","allPoses","heatmapScoresRaw","offsetsRaw","displacementFwdRaw","displacementBwdRaw","scaledSegmentScores","scaledLongOffsets","instanceMasks","segmentPersonPartsActivation","scaledPartSegmentationScores","loadMobileNet","tf","url","graphModel","tfconv.loadGraphModel","modelUrl","mobilenet","loadResNet","resnet","load","cpuBlur","canvas","blur","ctx","getContext","sum","alphaLeft","PI","step","exp","globalAlpha","drawImage","offScreenCanvases","isSafari","test","navigator","userAgent","assertSameDimensions","widthA","heightA","widthB","heightB","nameA","nameB","flipCanvasHorizontal","scale","translate","drawWithCompositing","compositOperation","globalCompositeOperation","createOffScreenCanvas","document","createElement","ensureOffscreenCanvasCreated","drawAndBlurImageOnCanvas","blurAmount","clearRect","save","restore","drawAndBlurImageOnOffScreenCanvas","offscreenCanvasName","renderImageToCanvas","renderImageDataToCanvas","putImageData","renderImageDataToOffScreenCanvas","canvasName","toMask","personOrPartSegmentation","foreground","r","g","background","drawContour","foregroundIds","isArray","multiPersonOrPartSegmentation","bytes","Uint8ClampedArray","drawStroke","row","column","radius","color","isSegmentationBoundary","segmentationData","numberBackgroundPixels","n_1","isBoundary","RAINBOW_PART_COLORS","toColoredPartMask","partColors","multiPersonPartSegmentation","partId","CANVAS_NAMES","blurred","blurredMask","lowresPartMask","drawMask","maskImage","maskOpacity","maskBlurAmount","drawPixelatedMask","pixelCellWidth","offscreenCanvas","offscreenCanvasCtx","imageSmoothingEnabled","beginPath","strokeStyle","moveTo","lineTo","stroke","createPersonMask","multiPersonSegmentation","edgeBlurAmount","backgroundMask","drawBokehEffect","backgroundBlurAmount","blurredImage","personMask","createBodyPartMask","bodyPartIdsToMask","blurBodyPart","bodyPartIdsToBlur","bodyPartMask","PART_CHANNELS","version"],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport * as tf from '@tensorflow/tfjs-core';\n\n/**\n * Takes the sigmoid of the part heatmap output and generates a 2d one-hot\n * tensor with ones where the part's score has the maximum value.\n *\n * @param partHeatmapScores\n */\nfunction toFlattenedOneHotPartMap(partHeatmapScores: tf.Tensor3D): tf.Tensor2D {\n  const numParts = partHeatmapScores.shape[2];\n  const partMapLocations = tf.argMax(partHeatmapScores, 2);\n\n  const partMapFlattened = tf.reshape(partMapLocations, [-1]);\n\n  return tf.oneHot(partMapFlattened, numParts) as tf.Tensor2D;\n}\n\nfunction clipByMask2d(image: tf.Tensor2D, mask: tf.Tensor2D): tf.Tensor2D {\n  return tf.mul(image, mask);\n}\n\n/**\n * Takes the sigmoid of the segmentation output, and generates a segmentation\n * mask with a 1 or 0 at each pixel where there is a person or not a person. The\n * segmentation threshold determines the threshold of a score for a pixel for it\n * to be considered part of a person.\n * @param segmentScores A 3d-tensor of the sigmoid of the segmentation output.\n * @param segmentationThreshold The minimum that segmentation values must have\n * to be considered part of the person.  Affects the generation of the\n * segmentation mask and the clipping of the colored part image.\n *\n * @returns A segmentation mask with a 1 or 0 at each pixel where there is a\n * person or not a person.\n */\nexport function toMaskTensor(\n    segmentScores: tf.Tensor2D, threshold: number): tf.Tensor2D {\n  return tf.tidy(\n      () =>\n          (tf.cast(tf.greater(\n              segmentScores, tf.scalar(threshold)), 'int32') as tf.Tensor2D));\n}\n\n/**\n * Takes the sigmoid of the person and part map output, and returns a 2d tensor\n * of an image with the corresponding value at each pixel corresponding to the\n * part with the highest value. These part ids are clipped by the segmentation\n * mask. Wherever the a pixel is clipped by the segmentation mask, its value\n * will set to -1, indicating that there is no part in that pixel.\n * @param segmentScores A 3d-tensor of the sigmoid of the segmentation output.\n * @param partHeatmapScores A 3d-tensor of the sigmoid of the part heatmap\n * output. The third dimension corresponds to the part.\n *\n * @returns A 2d tensor of an image with the corresponding value at each pixel\n * corresponding to the part with the highest value. These part ids are clipped\n * by the segmentation mask.  It will have values of -1 for pixels that are\n * outside of the body and do not have a corresponding part.\n */\nexport function decodePartSegmentation(\n    segmentationMask: tf.Tensor2D,\n    partHeatmapScores: tf.Tensor3D): tf.Tensor2D {\n  const [partMapHeight, partMapWidth, numParts] = partHeatmapScores.shape;\n  return tf.tidy(() => {\n    const flattenedMap = toFlattenedOneHotPartMap(partHeatmapScores);\n    const partNumbers = tf.expandDims(tf.range(0, numParts, 1, 'int32'), 1);\n\n    const partMapFlattened =\n        tf.cast(tf.matMul(flattenedMap, partNumbers as tf.Tensor2D), 'int32');\n\n    const partMap = tf.reshape(partMapFlattened, [partMapHeight, partMapWidth]);\n\n    const partMapShiftedUpForClipping = tf.add(partMap, tf.scalar(1, 'int32'));\n\n    return tf.sub(clipByMask2d(\n               partMapShiftedUpForClipping as tf.Tensor2D, segmentationMask)\n        , tf.scalar(1, 'int32'));\n  });\n}\n\nexport function decodeOnlyPartSegmentation(partHeatmapScores: tf.Tensor3D):\n    tf.Tensor2D {\n  const [partMapHeight, partMapWidth, numParts] = partHeatmapScores.shape;\n  return tf.tidy(() => {\n    const flattenedMap = toFlattenedOneHotPartMap(partHeatmapScores);\n    const partNumbers = tf.expandDims(tf.range(0, numParts, 1, 'int32'), 1);\n\n    const partMapFlattened =\n        tf.cast(tf.matMul(flattenedMap, partNumbers as tf.Tensor2D), 'int32');\n\n    return tf.reshape(partMapFlattened, [partMapHeight, partMapWidth]);\n  });\n}\n","\n/**\n * @license\n * Copyright 2019 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport * as tfconv from '@tensorflow/tfjs-converter';\nimport * as tf from '@tensorflow/tfjs-core';\nimport {BodyPixOutputStride} from './types';\n\n/**\n * BodyPix supports using various convolution neural network models\n * (e.g. ResNet and MobileNetV1) as its underlying base model.\n * The following BaseModel interface defines a unified interface for\n * creating such BodyPix base models. Currently both MobileNet (in\n * ./mobilenet.ts) and ResNet (in ./resnet.ts) implements the BaseModel\n * interface. New base models that conform to the BaseModel interface can be\n * added to BodyPix.\n */\nexport abstract class BaseModel {\n  constructor(\n      protected readonly model: tfconv.GraphModel,\n      public readonly outputStride: BodyPixOutputStride) {\n    const inputShape =\n        this.model.inputs[0].shape as [number, number, number, number];\n    tf.util.assert(\n        (inputShape[1] === -1) && (inputShape[2] === -1),\n        () => `Input shape [${inputShape[1]}, ${inputShape[2]}] ` +\n            `must both be equal to or -1`);\n  }\n\n  abstract preprocessInput(input: tf.Tensor3D): tf.Tensor3D;\n\n  /**\n   * Predicts intermediate Tensor representations.\n   *\n   * @param input The input RGB image of the base model.\n   * A Tensor of shape: [`inputResolution`, `inputResolution`, 3].\n   *\n   * @return A dictionary of base model's intermediate predictions.\n   * The returned dictionary should contains the following elements:\n   * - heatmapScores: A Tensor3D that represents the keypoint heatmap scores.\n   * - offsets: A Tensor3D that represents the offsets.\n   * - displacementFwd: A Tensor3D that represents the forward displacement.\n   * - displacementBwd: A Tensor3D that represents the backward displacement.\n   * - segmentation: A Tensor3D that represents the segmentation of all\n   * people.\n   * - longOffsets: A Tensor3D that represents the long offsets used for\n   * instance grouping.\n   * - partHeatmaps: A Tensor3D that represents the body part segmentation.\n   */\n  predict(input: tf.Tensor3D): {\n    heatmapScores: tf.Tensor3D,\n    offsets: tf.Tensor3D,\n    displacementFwd: tf.Tensor3D,\n    displacementBwd: tf.Tensor3D,\n    segmentation: tf.Tensor3D,\n    partHeatmaps: tf.Tensor3D,\n    longOffsets: tf.Tensor3D,\n    partOffsets: tf.Tensor3D\n  } {\n    return tf.tidy(() => {\n      const asFloat = this.preprocessInput(tf.cast(input, 'float32'));\n      const asBatch = tf.expandDims(asFloat, 0);\n      const results = this.model.predict(asBatch) as tf.Tensor4D[];\n      const results3d: tf.Tensor3D[] = results.map(y => tf.squeeze(y, [0]));\n      const namedResults = this.nameOutputResults(results3d);\n\n      return {\n        heatmapScores: tf.sigmoid(namedResults.heatmap),\n        offsets: namedResults.offsets,\n        displacementFwd: namedResults.displacementFwd,\n        displacementBwd: namedResults.displacementBwd,\n        segmentation: namedResults.segmentation,\n        partHeatmaps: namedResults.partHeatmaps,\n        longOffsets: namedResults.longOffsets,\n        partOffsets: namedResults.partOffsets\n      };\n    });\n  }\n\n  // Because MobileNet and ResNet predict() methods output a different order for\n  // these values, we have a method that needs to be implemented to order them.\n  abstract nameOutputResults(results: tf.Tensor3D[]): {\n    heatmap: tf.Tensor3D,\n    offsets: tf.Tensor3D,\n    displacementFwd: tf.Tensor3D,\n    displacementBwd: tf.Tensor3D,\n    segmentation: tf.Tensor3D,\n    partHeatmaps: tf.Tensor3D,\n    longOffsets: tf.Tensor3D,\n    partOffsets: tf.Tensor3D\n  };\n\n  /**\n   * Releases the CPU and GPU memory allocated by the model.\n   */\n  dispose() {\n    this.model.dispose();\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport * as tf from '@tensorflow/tfjs-core';\n\nimport {BaseModel} from './base_model';\n\nexport class MobileNet extends BaseModel {\n  preprocessInput(input: tf.Tensor3D): tf.Tensor3D {\n    // Normalize the pixels [0, 255] to be between [-1, 1].\n    return tf.tidy(() => tf.sub(tf.div(input, 127.5), 1.0));\n  }\n\n  nameOutputResults(results: tf.Tensor3D[]) {\n    const [\n      offsets,\n      segmentation,\n      partHeatmaps,\n      longOffsets,\n      heatmap,\n      displacementFwd,\n      displacementBwd,\n      partOffsets,\n  ] = results;\n    return {\n      offsets,\n      segmentation,\n      partHeatmaps,\n      longOffsets,\n      heatmap,\n      displacementFwd,\n      displacementBwd,\n      partOffsets\n    };\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nexport type Tuple<T> = [T, T];\nexport type StringTuple = Tuple<string>;\nexport type NumberTuple = Tuple<number>;\n\nexport const PART_NAMES = [\n  'nose', 'leftEye', 'rightEye', 'leftEar', 'rightEar', 'leftShoulder',\n  'rightShoulder', 'leftElbow', 'rightElbow', 'leftWrist', 'rightWrist',\n  'leftHip', 'rightHip', 'leftKnee', 'rightKnee', 'leftAnkle', 'rightAnkle'\n];\n\nexport const NUM_KEYPOINTS = PART_NAMES.length;\n\nexport interface NumberDict {\n  [jointName: string]: number;\n}\n\nexport const PART_IDS =\n    PART_NAMES.reduce((result: NumberDict, jointName, i): NumberDict => {\n      result[jointName] = i;\n      return result;\n    }, {}) as NumberDict;\n\nconst CONNECTED_PART_NAMES: StringTuple[] = [\n  ['leftHip', 'leftShoulder'], ['leftElbow', 'leftShoulder'],\n  ['leftElbow', 'leftWrist'], ['leftHip', 'leftKnee'],\n  ['leftKnee', 'leftAnkle'], ['rightHip', 'rightShoulder'],\n  ['rightElbow', 'rightShoulder'], ['rightElbow', 'rightWrist'],\n  ['rightHip', 'rightKnee'], ['rightKnee', 'rightAnkle'],\n  ['leftShoulder', 'rightShoulder'], ['leftHip', 'rightHip']\n];\n\n/*\n * Define the skeleton. This defines the parent->child relationships of our\n * tree. Arbitrarily this defines the nose as the root of the tree, however\n * since we will infer the displacement for both parent->child and\n * child->parent, we can define the tree root as any node.\n */\nexport const POSE_CHAIN: StringTuple[] = [\n  ['nose', 'leftEye'], ['leftEye', 'leftEar'], ['nose', 'rightEye'],\n  ['rightEye', 'rightEar'], ['nose', 'leftShoulder'],\n  ['leftShoulder', 'leftElbow'], ['leftElbow', 'leftWrist'],\n  ['leftShoulder', 'leftHip'], ['leftHip', 'leftKnee'],\n  ['leftKnee', 'leftAnkle'], ['nose', 'rightShoulder'],\n  ['rightShoulder', 'rightElbow'], ['rightElbow', 'rightWrist'],\n  ['rightShoulder', 'rightHip'], ['rightHip', 'rightKnee'],\n  ['rightKnee', 'rightAnkle']\n];\n\nexport const CONNECTED_PART_INDICES = CONNECTED_PART_NAMES.map(\n    ([jointNameA, jointNameB]) =>\n        ([PART_IDS[jointNameA], PART_IDS[jointNameB]]));\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {NUM_KEYPOINTS} from '../keypoints';\nimport {Padding, Part, TensorBuffer3D, Vector2D} from '../types';\n\nexport function getScale(\n    [height, width]: [number, number],\n    [inputResolutionY, inputResolutionX]: [number, number],\n    padding: Padding): [number, number] {\n  const {top: padT, bottom: padB, left: padL, right: padR} = padding;\n  const scaleY = inputResolutionY / (padT + padB + height);\n  const scaleX = inputResolutionX / (padL + padR + width);\n  return [scaleX, scaleY];\n}\n\nexport function getOffsetPoint(\n    y: number, x: number, keypoint: number, offsets: TensorBuffer3D): Vector2D {\n  return {\n    y: offsets.get(y, x, keypoint),\n    x: offsets.get(y, x, keypoint + NUM_KEYPOINTS)\n  };\n}\n\nexport function getImageCoords(\n    part: Part, outputStride: number, offsets: TensorBuffer3D): Vector2D {\n  const {heatmapY, heatmapX, id: keypoint} = part;\n  const {y, x} = getOffsetPoint(heatmapY, heatmapX, keypoint, offsets);\n  return {\n    x: part.heatmapX * outputStride + x,\n    y: part.heatmapY * outputStride + y\n  };\n}\n\nexport function fillArray<T>(element: T, size: number): T[] {\n  const result: T[] = new Array(size);\n\n  for (let i = 0; i < size; i++) {\n    result[i] = element;\n  }\n\n  return result;\n}\n\nexport function clamp(a: number, min: number, max: number): number {\n  if (a < min) {\n    return min;\n  }\n  if (a > max) {\n    return max;\n  }\n  return a;\n}\n\nexport function squaredDistance(\n    y1: number, x1: number, y2: number, x2: number): number {\n  const dy = y2 - y1;\n  const dx = x2 - x1;\n  return dy * dy + dx * dx;\n}\n\nexport function addVectors(a: Vector2D, b: Vector2D): Vector2D {\n  return {x: a.x + b.x, y: a.y + b.y};\n}\n\nexport function clampVector(a: Vector2D, min: number, max: number): Vector2D {\n  return {y: clamp(a.y, min, max), x: clamp(a.x, min, max)};\n}\n","/**\n * @license\n * Copyright 2019 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {NUM_KEYPOINTS} from '../keypoints';\nimport {Padding, Pose} from '../types';\n\nimport {getScale} from './util';\n\ninterface Pair {\n  x: number;\n  y: number;\n}\n\nfunction computeDistance(embedding: Pair[], pose: Pose, minPartScore = 0.3) {\n  let distance = 0.0;\n  let numKpt = 0;\n  for (let p = 0; p < embedding.length; p++) {\n    if (pose.keypoints[p].score > minPartScore) {\n      numKpt += 1;\n      distance += (embedding[p].x - pose.keypoints[p].position.x) ** 2 +\n          (embedding[p].y - pose.keypoints[p].position.y) ** 2;\n    }\n  }\n  if (numKpt === 0) {\n    distance = Infinity;\n  } else {\n    distance = distance / numKpt;\n  }\n  return distance;\n}\n\nfunction convertToPositionInOuput(\n    position: Pair, [padT, padL]: [number, number],\n    [scaleX, scaleY]: [number, number], stride: number): Pair {\n  const y = Math.round(((padT + position.y + 1.0) * scaleY - 1.0) / stride);\n  const x = Math.round(((padL + position.x + 1.0) * scaleX - 1.0) / stride);\n  return {x, y};\n}\n\nfunction getEmbedding(\n    location: Pair, keypointIndex: number,\n    convertToPosition: (pair: Pair) => Pair, outputResolutionX: number,\n    longOffsets: Float32Array, refineSteps: number,\n    [height, width]: [number, number]): Pair {\n  const newLocation = convertToPosition(location);\n\n  const nn = newLocation.y * outputResolutionX + newLocation.x;\n  let dy = longOffsets[NUM_KEYPOINTS * (2 * nn) + keypointIndex];\n  let dx = longOffsets[NUM_KEYPOINTS * (2 * nn + 1) + keypointIndex];\n  let y = location.y + dy;\n  let x = location.x + dx;\n  for (let t = 0; t < refineSteps; t++) {\n    y = Math.min(y, height - 1);\n    x = Math.min(x, width - 1);\n    const newPos = convertToPosition({x, y});\n    const nn = newPos.y * outputResolutionX + newPos.x;\n    dy = longOffsets[NUM_KEYPOINTS * (2 * nn) + keypointIndex];\n    dx = longOffsets[NUM_KEYPOINTS * (2 * nn + 1) + keypointIndex];\n    y = y + dy;\n    x = x + dx;\n  }\n\n  return {x, y};\n}\n\nfunction matchEmbeddingToInstance(\n    location: Pair, longOffsets: Float32Array, poses: Pose[],\n    numKptForMatching: number, [padT, padL]: [number, number],\n    [scaleX, scaleY]: [number, number], outputResolutionX: number,\n    [height, width]: [number, number], stride: number,\n    refineSteps: number): number {\n  const embed: Pair[] = [];\n  const convertToPosition = (pair: Pair) =>\n      convertToPositionInOuput(pair, [padT, padL], [scaleX, scaleY], stride);\n\n  for (let keypointsIndex = 0; keypointsIndex < numKptForMatching;\n       keypointsIndex++) {\n    const embedding = getEmbedding(\n        location, keypointsIndex, convertToPosition, outputResolutionX,\n        longOffsets, refineSteps, [height, width]);\n\n    embed.push(embedding);\n  }\n\n  let kMin = -1;\n  let kMinDist = Infinity;\n  for (let k = 0; k < poses.length; k++) {\n    const dist = computeDistance(embed, poses[k]);\n    if (dist < kMinDist) {\n      kMin = k;\n      kMinDist = dist;\n    }\n  }\n  return kMin;\n}\n\nfunction getOutputResolution(\n    [inputResolutionY, inputResolutionX]: [number, number],\n    stride: number): [number, number] {\n  const outputResolutionX = Math.round((inputResolutionX - 1.0) / stride + 1.0);\n  const outputResolutionY = Math.round((inputResolutionY - 1.0) / stride + 1.0);\n  return [outputResolutionX, outputResolutionY];\n}\n\nexport function decodeMultipleMasksCPU(\n    segmentation: Uint8Array, longOffsets: Float32Array,\n    posesAboveScore: Pose[], height: number, width: number, stride: number,\n    [inHeight, inWidth]: [number, number], padding: Padding,\n    refineSteps: number, numKptForMatching = 5): Uint8Array[] {\n  const dataArrays =\n      posesAboveScore.map(x => new Uint8Array(height * width).fill(0));\n\n  const {top: padT, left: padL} = padding;\n\n  const [scaleX, scaleY] =\n      getScale([height, width], [inHeight, inWidth], padding);\n  const [outputResolutionX, ] =\n    getOutputResolution([inHeight, inWidth], stride);\n  for (let i = 0; i < height; i += 1) {\n    for (let j = 0; j < width; j += 1) {\n      const n = i * width + j;\n      const prob = segmentation[n];\n      if (prob === 1) {\n        const kMin = matchEmbeddingToInstance(\n            {x: j, y: i}, longOffsets, posesAboveScore, numKptForMatching,\n            [padT, padL], [scaleX, scaleY], outputResolutionX, [height, width],\n            stride, refineSteps);\n        if (kMin >= 0) {\n          dataArrays[kMin][n] = 1;\n        }\n      }\n    }\n  }\n\n  return dataArrays;\n}\n\nexport function decodeMultiplePartMasksCPU(\n    segmentation: Uint8Array, longOffsets: Float32Array,\n    partSegmentaion: Uint8Array, posesAboveScore: Pose[], height: number,\n    width: number, stride: number, [inHeight, inWidth]: [number, number],\n    padding: Padding, refineSteps: number,\n    numKptForMatching = 5): Int32Array[] {\n  const dataArrays =\n      posesAboveScore.map(x => new Int32Array(height * width).fill(-1));\n\n  const {top: padT, left: padL} = padding;\n\n  const [scaleX, scaleY] =\n      getScale([height, width], [inHeight, inWidth], padding);\n  const [outputResolutionX, ] =\n    getOutputResolution([inHeight, inWidth], stride);\n\n  for (let i = 0; i < height; i += 1) {\n    for (let j = 0; j < width; j += 1) {\n      const n = i * width + j;\n      const prob = segmentation[n];\n      if (prob === 1) {\n        const kMin = matchEmbeddingToInstance(\n            {x: j, y: i}, longOffsets, posesAboveScore, numKptForMatching,\n            [padT, padL], [scaleX, scaleY], outputResolutionX, [height, width],\n            stride, refineSteps);\n        if (kMin >= 0) {\n          dataArrays[kMin][n] = partSegmentaion[n];\n        }\n      }\n    }\n  }\n\n  return dataArrays;\n}\n","/**\n * @license\n * Copyright 2019 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport * as tf from '@tensorflow/tfjs-core';\nimport * as tf_webgl from '@tensorflow/tfjs-backend-webgl';\n\nimport {NUM_KEYPOINTS} from '../keypoints';\nimport {Padding, Pose} from '../types';\nimport {getScale} from './util';\n\nexport function decodeMultipleMasksWebGl(\n    segmentation: tf.Tensor2D, longOffsets: tf.Tensor3D,\n    posesAboveScore: Pose[], height: number, width: number, stride: number,\n    [inHeight, inWidth]: [number, number], padding: Padding,\n    refineSteps: number, minKptScore: number,\n    maxNumPeople: number): tf.TensorInfo {\n  // The height/width of the image/canvas itself.\n  const [origHeight, origWidth] = segmentation.shape;\n  // The height/width of the output of the model.\n  const [outHeight, outWidth] = longOffsets.shape.slice(0, 2);\n\n  const shapedLongOffsets: tf.Tensor4D =\n      tf.reshape(longOffsets, [outHeight, outWidth, 2, NUM_KEYPOINTS]);\n\n  // Make pose tensor of shape [MAX_NUM_PEOPLE, NUM_KEYPOINTS, 3] where\n  // the last 3 coordinates correspond to the score, h and w coordinate of that\n  // keypoint.\n  const poseVals = new Float32Array(maxNumPeople * NUM_KEYPOINTS * 3).fill(0.0);\n  for (let i = 0; i < posesAboveScore.length; i++) {\n    const poseOffset = i * NUM_KEYPOINTS * 3;\n    const pose = posesAboveScore[i];\n    for (let kp = 0; kp < NUM_KEYPOINTS; kp++) {\n      const keypoint = pose.keypoints[kp];\n      const offset = poseOffset + kp * 3;\n      poseVals[offset] = keypoint.score;\n      poseVals[offset + 1] = keypoint.position.y;\n      poseVals[offset + 2] = keypoint.position.x;\n    }\n  }\n\n  const [scaleX, scaleY] =\n      getScale([height, width], [inHeight, inWidth], padding);\n\n  const posesTensor = tf.tensor(poseVals, [maxNumPeople, NUM_KEYPOINTS, 3]);\n\n  const {top: padT, left: padL} = padding;\n\n  const program: tf_webgl.GPGPUProgram = {\n    variableNames: ['segmentation', 'longOffsets', 'poses'],\n    outputShape: [origHeight, origWidth],\n    userCode: `\n    int convertToPositionInOutput(int pos, int pad, float scale, int stride) {\n      return round(((float(pos + pad) + 1.0) * scale - 1.0) / float(stride));\n    }\n\n    float convertToPositionInOutputFloat(\n        int pos, int pad, float scale, int stride) {\n      return ((float(pos + pad) + 1.0) * scale - 1.0) / float(stride);\n    }\n\n    float dist(float x1, float y1, float x2, float y2) {\n      return pow(x1 - x2, 2.0) + pow(y1 - y2, 2.0);\n    }\n\n    float sampleLongOffsets(float h, float w, int d, int k) {\n      float fh = fract(h);\n      float fw = fract(w);\n      int clH = int(ceil(h));\n      int clW = int(ceil(w));\n      int flH = int(floor(h));\n      int flW = int(floor(w));\n      float o11 = getLongOffsets(flH, flW, d, k);\n      float o12 = getLongOffsets(flH, clW, d, k);\n      float o21 = getLongOffsets(clH, flW, d, k);\n      float o22 = getLongOffsets(clH, clW, d, k);\n      float o1 = mix(o11, o12, fw);\n      float o2 = mix(o21, o22, fw);\n      return mix(o1, o2, fh);\n    }\n\n    int findNearestPose(int h, int w) {\n      float prob = getSegmentation(h, w);\n      if (prob < 1.0) {\n        return -1;\n      }\n\n      // Done(Tyler): convert from output space h/w to strided space.\n      float stridedH = convertToPositionInOutputFloat(\n        h, ${padT}, ${scaleY}, ${stride});\n      float stridedW = convertToPositionInOutputFloat(\n        w, ${padL}, ${scaleX}, ${stride});\n\n      float minDist = 1000000.0;\n      int iMin = -1;\n      for (int i = 0; i < ${maxNumPeople}; i++) {\n        float curDistSum = 0.0;\n        int numKpt = 0;\n        for (int k = 0; k < ${NUM_KEYPOINTS}; k++) {\n          float dy = sampleLongOffsets(stridedH, stridedW, 0, k);\n          float dx = sampleLongOffsets(stridedH, stridedW, 1, k);\n\n          float y = float(h) + dy;\n          float x = float(w) + dx;\n\n          for (int s = 0; s < ${refineSteps}; s++) {\n            int yRounded = round(min(y, float(${height - 1.0})));\n            int xRounded = round(min(x, float(${width - 1.0})));\n\n            float yStrided = convertToPositionInOutputFloat(\n              yRounded, ${padT}, ${scaleY}, ${stride});\n            float xStrided = convertToPositionInOutputFloat(\n              xRounded, ${padL}, ${scaleX}, ${stride});\n\n            float dy = sampleLongOffsets(yStrided, xStrided, 0, k);\n            float dx = sampleLongOffsets(yStrided, xStrided, 1, k);\n\n            y = y + dy;\n            x = x + dx;\n          }\n\n          float poseScore = getPoses(i, k, 0);\n          float poseY = getPoses(i, k, 1);\n          float poseX = getPoses(i, k, 2);\n          if (poseScore > ${minKptScore}) {\n            numKpt = numKpt + 1;\n            curDistSum = curDistSum + dist(x, y, poseX, poseY);\n          }\n        }\n        if (numKpt > 0 && curDistSum / float(numKpt) < minDist) {\n          minDist = curDistSum / float(numKpt);\n          iMin = i;\n        }\n      }\n      return iMin;\n    }\n\n    void main() {\n        ivec2 coords = getOutputCoords();\n        int nearestPose = findNearestPose(coords[0], coords[1]);\n        setOutput(float(nearestPose));\n      }\n  `\n  };\n  const webglBackend = tf.backend() as tf_webgl.MathBackendWebGL;\n  return webglBackend.compileAndRun(\n      program, [segmentation, shapedLongOffsets, posesTensor]);\n}\n","/**\n * @license\n * Copyright 2019 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport * as tf from '@tensorflow/tfjs-core';\nimport {getBackend} from '@tensorflow/tfjs-core';\n\nimport {Padding, PartSegmentation, PersonSegmentation, Pose} from '../types';\n\nimport {decodeMultipleMasksCPU, decodeMultiplePartMasksCPU} from './decode_multiple_masks_cpu';\nimport {decodeMultipleMasksWebGl} from './decode_multiple_masks_webgl';\n\nexport function toPersonKSegmentation(\n    segmentation: tf.Tensor2D, k: number): tf.Tensor2D {\n  return tf.tidy(\n      () => (tf.cast(tf.equal(\n          segmentation, tf.scalar(k)), 'int32') as tf.Tensor2D));\n}\n\nexport function toPersonKPartSegmentation(\n    segmentation: tf.Tensor2D, bodyParts: tf.Tensor2D, k: number): tf.Tensor2D {\n  return tf.tidy(\n      () => tf.sub(tf.mul(tf.cast(tf.equal(\n          segmentation, tf.scalar(k)), 'int32'), tf.add(bodyParts, 1)), 1));\n}\n\nfunction isWebGlBackend() {\n  return getBackend() === 'webgl';\n}\n\nexport async function decodePersonInstanceMasks(\n    segmentation: tf.Tensor2D, longOffsets: tf.Tensor3D, poses: Pose[],\n    height: number, width: number, stride: number,\n    [inHeight, inWidth]: [number, number], padding: Padding, minPoseScore = 0.2,\n    refineSteps = 8, minKeypointScore = 0.3,\n    maxNumPeople = 10): Promise<PersonSegmentation[]> {\n  // Filter out poses with smaller score.\n  const posesAboveScore = poses.filter(pose => pose.score >= minPoseScore);\n\n  let personSegmentationsData: Uint8Array[];\n\n  if (isWebGlBackend()) {\n    const personSegmentations = tf.tidy(() => {\n      const masksTensorInfo = decodeMultipleMasksWebGl(\n          segmentation, longOffsets, posesAboveScore, height, width, stride,\n          [inHeight, inWidth], padding, refineSteps, minKeypointScore,\n          maxNumPeople);\n      const masksTensor = tf.engine().makeTensorFromDataId(\n          masksTensorInfo.dataId, masksTensorInfo.shape,\n          masksTensorInfo.dtype) as tf.Tensor2D;\n\n      return posesAboveScore.map(\n          (_, k) => toPersonKSegmentation(masksTensor, k));\n    });\n\n    personSegmentationsData =\n        (await Promise.all(personSegmentations.map(mask => mask.data())) as\n         Uint8Array[]);\n\n    personSegmentations.forEach(x => x.dispose());\n  } else {\n    const segmentationsData = await segmentation.data() as Uint8Array;\n    const longOffsetsData = await longOffsets.data() as Float32Array;\n\n    personSegmentationsData = decodeMultipleMasksCPU(\n        segmentationsData, longOffsetsData, posesAboveScore, height, width,\n        stride, [inHeight, inWidth], padding, refineSteps);\n  }\n\n  return personSegmentationsData.map(\n      (data, i) => ({data, pose: posesAboveScore[i], width, height}));\n}\n\nexport async function decodePersonInstancePartMasks(\n    segmentation: tf.Tensor2D, longOffsets: tf.Tensor3D,\n    partSegmentation: tf.Tensor2D, poses: Pose[], height: number, width: number,\n    stride: number, [inHeight, inWidth]: [number, number], padding: Padding,\n    minPoseScore = 0.2, refineSteps = 8, minKeypointScore = 0.3,\n    maxNumPeople = 10): Promise<PartSegmentation[]> {\n  const posesAboveScore = poses.filter(pose => pose.score >= minPoseScore);\n\n  let partSegmentationsByPersonData: Int32Array[];\n\n  if (isWebGlBackend()) {\n    const partSegmentations = tf.tidy(() => {\n      const masksTensorInfo = decodeMultipleMasksWebGl(\n          segmentation, longOffsets, posesAboveScore, height, width, stride,\n          [inHeight, inWidth], padding, refineSteps, minKeypointScore,\n          maxNumPeople);\n      const masksTensor = tf.engine().makeTensorFromDataId(\n        masksTensorInfo.dataId, masksTensorInfo.shape,\n        masksTensorInfo.dtype) as tf.Tensor2D;\n\n      return posesAboveScore.map(\n          (_, k) =>\n              toPersonKPartSegmentation(masksTensor, partSegmentation, k));\n    });\n\n    partSegmentationsByPersonData =\n        (await Promise.all(partSegmentations.map(x => x.data()))) as\n        Int32Array[];\n\n    partSegmentations.forEach(x => x.dispose());\n  } else {\n    const segmentationsData = await segmentation.data() as Uint8Array;\n    const longOffsetsData = await longOffsets.data() as Float32Array;\n    const partSegmentaionData = await partSegmentation.data() as Uint8Array;\n\n    partSegmentationsByPersonData = decodeMultiplePartMasksCPU(\n        segmentationsData, longOffsetsData, partSegmentaionData,\n        posesAboveScore, height, width, stride, [inHeight, inWidth], padding,\n        refineSteps);\n  }\n\n  return partSegmentationsByPersonData.map(\n      (data, k) => ({pose: posesAboveScore[k], data, height, width}));\n}\n","/**\n * @license\n * Copyright 2019 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\n// algorithm based on Coursera Lecture from Algorithms, Part 1:\n// https://www.coursera.org/learn/algorithms-part1/lecture/ZjoSM/heapsort\n\nfunction half(k: number) {\n  return Math.floor(k / 2);\n}\n\nexport class MaxHeap<T> {\n  private priorityQueue: T[];\n  private numberOfElements: number;\n  private getElementValue: (element: T) => number;\n\n  constructor(maxSize: number, getElementValue: (element: T) => number) {\n    this.priorityQueue = new Array(maxSize);\n    this.numberOfElements = -1;\n    this.getElementValue = getElementValue;\n  }\n\n  public enqueue(x: T): void {\n    this.priorityQueue[++this.numberOfElements] = x;\n    this.swim(this.numberOfElements);\n  }\n\n  public dequeue(): T {\n    const max = this.priorityQueue[0];\n    this.exchange(0, this.numberOfElements--);\n    this.sink(0);\n    this.priorityQueue[this.numberOfElements + 1] = null;\n    return max;\n  }\n\n  public empty(): boolean {\n    return this.numberOfElements === -1;\n  }\n\n  public size(): number {\n    return this.numberOfElements + 1;\n  }\n\n  public all(): T[] {\n    return this.priorityQueue.slice(0, this.numberOfElements + 1);\n  }\n\n  public max(): T {\n    return this.priorityQueue[0];\n  }\n\n  private swim(k: number): void {\n    while (k > 0 && this.less(half(k), k)) {\n      this.exchange(k, half(k));\n      k = half(k);\n    }\n  }\n\n  private sink(k: number): void {\n    while (2 * k <= this.numberOfElements) {\n      let j = 2 * k;\n      if (j < this.numberOfElements && this.less(j, j + 1)) {\n        j++;\n      }\n      if (!this.less(k, j)) {\n        break;\n      }\n      this.exchange(k, j);\n      k = j;\n    }\n  }\n\n  private getValueAt(i: number): number {\n    return this.getElementValue(this.priorityQueue[i]);\n  }\n\n  private less(i: number, j: number): boolean {\n    return this.getValueAt(i) < this.getValueAt(j);\n  }\n\n  private exchange(i: number, j: number): void {\n    const t = this.priorityQueue[i];\n    this.priorityQueue[i] = this.priorityQueue[j];\n    this.priorityQueue[j] = t;\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {PartWithScore, TensorBuffer3D} from '../types';\n\nimport {MaxHeap} from './max_heap';\n\nfunction scoreIsMaximumInLocalWindow(\n    keypointId: number, score: number, heatmapY: number, heatmapX: number,\n    localMaximumRadius: number, scores: TensorBuffer3D): boolean {\n  const [height, width] = scores.shape;\n\n  let localMaximum = true;\n  const yStart = Math.max(heatmapY - localMaximumRadius, 0);\n  const yEnd = Math.min(heatmapY + localMaximumRadius + 1, height);\n  for (let yCurrent = yStart; yCurrent < yEnd; ++yCurrent) {\n    const xStart = Math.max(heatmapX - localMaximumRadius, 0);\n    const xEnd = Math.min(heatmapX + localMaximumRadius + 1, width);\n    for (let xCurrent = xStart; xCurrent < xEnd; ++xCurrent) {\n      if (scores.get(yCurrent, xCurrent, keypointId) > score) {\n        localMaximum = false;\n        break;\n      }\n    }\n    if (!localMaximum) {\n      break;\n    }\n  }\n\n  return localMaximum;\n}\n\n/**\n * Builds a priority queue with part candidate positions for a specific image in\n * the batch. For this we find all local maxima in the score maps with score\n * values above a threshold. We create a single priority queue across all parts.\n */\nexport function buildPartWithScoreQueue(\n    scoreThreshold: number, localMaximumRadius: number,\n    scores: TensorBuffer3D): MaxHeap<PartWithScore> {\n  const [height, width, numKeypoints] = scores.shape;\n\n  const queue = new MaxHeap<PartWithScore>(\n      height * width * numKeypoints, ({score}) => score);\n\n  for (let heatmapY = 0; heatmapY < height; ++heatmapY) {\n    for (let heatmapX = 0; heatmapX < width; ++heatmapX) {\n      for (let keypointId = 0; keypointId < numKeypoints; ++keypointId) {\n        const score = scores.get(heatmapY, heatmapX, keypointId);\n\n        // Only consider parts with score greater or equal to threshold as\n        // root candidates.\n        if (score < scoreThreshold) {\n          continue;\n        }\n\n        // Only consider keypoints whose score is maximum in a local window.\n        if (scoreIsMaximumInLocalWindow(\n                keypointId, score, heatmapY, heatmapX, localMaximumRadius,\n                scores)) {\n          queue.enqueue({score, part: {heatmapY, heatmapX, id: keypointId}});\n        }\n      }\n    }\n  }\n\n  return queue;\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {NumberTuple, PART_IDS, PART_NAMES, POSE_CHAIN} from '../keypoints';\nimport {Keypoint, PartWithScore, TensorBuffer3D, Vector2D} from '../types';\n\nimport {clamp, getOffsetPoint} from './util';\nimport {addVectors, getImageCoords} from './util';\n\nconst parentChildrenTuples: NumberTuple[] = POSE_CHAIN.map(\n    ([parentJoinName, childJoinName]): NumberTuple =>\n        ([PART_IDS[parentJoinName], PART_IDS[childJoinName]]));\n\nconst parentToChildEdges: number[] =\n    parentChildrenTuples.map(([, childJointId]) => childJointId);\n\nconst childToParentEdges: number[] =\n    parentChildrenTuples.map(([\n                               parentJointId,\n                             ]) => parentJointId);\n\nfunction getDisplacement(\n    edgeId: number, point: Vector2D, displacements: TensorBuffer3D): Vector2D {\n  const numEdges = displacements.shape[2] / 2;\n  return {\n    y: displacements.get(point.y, point.x, edgeId),\n    x: displacements.get(point.y, point.x, numEdges + edgeId)\n  };\n}\n\nfunction getStridedIndexNearPoint(\n    point: Vector2D, outputStride: number, height: number,\n    width: number): Vector2D {\n  return {\n    y: clamp(Math.round(point.y / outputStride), 0, height - 1),\n    x: clamp(Math.round(point.x / outputStride), 0, width - 1)\n  };\n}\n\n/**\n * We get a new keypoint along the `edgeId` for the pose instance, assuming\n * that the position of the `idSource` part is already known. For this, we\n * follow the displacement vector from the source to target part (stored in\n * the `i`-t channel of the displacement tensor). The displaced keypoint\n * vector is refined using the offset vector by `offsetRefineStep` times.\n */\nfunction traverseToTargetKeypoint(\n    edgeId: number, sourceKeypoint: Keypoint, targetKeypointId: number,\n    scoresBuffer: TensorBuffer3D, offsets: TensorBuffer3D, outputStride: number,\n    displacements: TensorBuffer3D, offsetRefineStep = 2): Keypoint {\n  const [height, width] = scoresBuffer.shape;\n\n  // Nearest neighbor interpolation for the source->target displacements.\n  const sourceKeypointIndices = getStridedIndexNearPoint(\n      sourceKeypoint.position, outputStride, height, width);\n\n  const displacement =\n      getDisplacement(edgeId, sourceKeypointIndices, displacements);\n\n  const displacedPoint = addVectors(sourceKeypoint.position, displacement);\n  let targetKeypoint = displacedPoint;\n  for (let i = 0; i < offsetRefineStep; i++) {\n    const targetKeypointIndices =\n        getStridedIndexNearPoint(targetKeypoint, outputStride, height, width);\n\n    const offsetPoint = getOffsetPoint(\n        targetKeypointIndices.y, targetKeypointIndices.x, targetKeypointId,\n        offsets);\n\n    targetKeypoint = addVectors(\n        {\n          x: targetKeypointIndices.x * outputStride,\n          y: targetKeypointIndices.y * outputStride\n        },\n        {x: offsetPoint.x, y: offsetPoint.y});\n  }\n  const targetKeyPointIndices =\n      getStridedIndexNearPoint(targetKeypoint, outputStride, height, width);\n  const score = scoresBuffer.get(\n      targetKeyPointIndices.y, targetKeyPointIndices.x, targetKeypointId);\n\n  return {position: targetKeypoint, part: PART_NAMES[targetKeypointId], score};\n}\n\n/**\n * Follows the displacement fields to decode the full pose of the object\n * instance given the position of a part that acts as root.\n *\n * @return An array of decoded keypoints and their scores for a single pose\n */\nexport function decodePose(\n    root: PartWithScore, scores: TensorBuffer3D, offsets: TensorBuffer3D,\n    outputStride: number, displacementsFwd: TensorBuffer3D,\n    displacementsBwd: TensorBuffer3D): Keypoint[] {\n  const numParts = scores.shape[2];\n  const numEdges = parentToChildEdges.length;\n\n  const instanceKeypoints: Keypoint[] = new Array(numParts);\n  // Start a new detection instance at the position of the root.\n  const {part: rootPart, score: rootScore} = root;\n  const rootPoint = getImageCoords(rootPart, outputStride, offsets);\n\n  instanceKeypoints[rootPart.id] = {\n    score: rootScore,\n    part: PART_NAMES[rootPart.id],\n    position: rootPoint\n  };\n\n  // Decode the part positions upwards in the tree, following the backward\n  // displacements.\n  for (let edge = numEdges - 1; edge >= 0; --edge) {\n    const sourceKeypointId = parentToChildEdges[edge];\n    const targetKeypointId = childToParentEdges[edge];\n    if (instanceKeypoints[sourceKeypointId] &&\n        !instanceKeypoints[targetKeypointId]) {\n      instanceKeypoints[targetKeypointId] = traverseToTargetKeypoint(\n          edge, instanceKeypoints[sourceKeypointId], targetKeypointId, scores,\n          offsets, outputStride, displacementsBwd);\n    }\n  }\n\n  // Decode the part positions downwards in the tree, following the forward\n  // displacements.\n  for (let edge = 0; edge < numEdges; ++edge) {\n    const sourceKeypointId = childToParentEdges[edge];\n    const targetKeypointId = parentToChildEdges[edge];\n    if (instanceKeypoints[sourceKeypointId] &&\n        !instanceKeypoints[targetKeypointId]) {\n      instanceKeypoints[targetKeypointId] = traverseToTargetKeypoint(\n          edge, instanceKeypoints[sourceKeypointId], targetKeypointId, scores,\n          offsets, outputStride, displacementsFwd);\n    }\n  }\n\n  return instanceKeypoints;\n}\n","/**\n * @license\n * Copyright 2019 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Keypoint, Pose, TensorBuffer3D} from '../types';\n\nimport {buildPartWithScoreQueue} from './build_part_with_score_queue';\nimport {decodePose} from './decode_pose';\nimport {getImageCoords, squaredDistance} from './util';\n\nfunction withinNmsRadiusOfCorrespondingPoint(\n    poses: Pose[], squaredNmsRadius: number, {x, y}: {x: number, y: number},\n    keypointId: number): boolean {\n  return poses.some(({keypoints}) => {\n    const correspondingKeypoint = keypoints[keypointId].position;\n    return squaredDistance(\n               y, x, correspondingKeypoint.y, correspondingKeypoint.x) <=\n        squaredNmsRadius;\n  });\n}\n\n/* Score the newly proposed object instance without taking into account\n * the scores of the parts that overlap with any previously detected\n * instance.\n */\nfunction getInstanceScore(\n    existingPoses: Pose[], squaredNmsRadius: number,\n    instanceKeypoints: Keypoint[]): number {\n  let notOverlappedKeypointScores = instanceKeypoints.reduce(\n      (result, {position, score}, keypointId): number => {\n        if (!withinNmsRadiusOfCorrespondingPoint(\n                existingPoses, squaredNmsRadius, position, keypointId)) {\n          result += score;\n        }\n        return result;\n      }, 0.0);\n\n  return notOverlappedKeypointScores /= instanceKeypoints.length;\n}\n\n// A point (y, x) is considered as root part candidate if its score is a\n// maximum in a window |y - y'| <= kLocalMaximumRadius, |x - x'| <=\n// kLocalMaximumRadius.\nconst kLocalMaximumRadius = 1;\n\n/**\n * Detects multiple poses and finds their parts from part scores and\n * displacement vectors. It returns up to `maxDetections` object instance\n * detections in decreasing root score order. It works as follows: We first\n * create a priority queue with local part score maxima above\n * `scoreThreshold`, considering all parts at the same time. Then we\n * iteratively pull the top  element of the queue (in decreasing score order)\n * and treat it as a root candidate for a new object instance. To avoid\n * duplicate detections, we reject the root candidate if it is within a disk\n * of `nmsRadius` pixels from the corresponding part of a previously detected\n * instance, which is a form of part-based non-maximum suppression (NMS). If\n * the root candidate passes the NMS check, we start a new object instance\n * detection, treating the corresponding part as root and finding the\n * positions of the remaining parts by following the displacement vectors\n * along the tree-structured part graph. We assign to the newly detected\n * instance a score equal to the sum of scores of its parts which have not\n * been claimed by a previous instance (i.e., those at least `nmsRadius`\n * pixels away from the corresponding part of all previously detected\n * instances), divided by the total number of parts `numParts`.\n *\n * @param heatmapScores 3-D tensor with shape `[height, width, numParts]`.\n * The value of heatmapScores[y, x, k]` is the score of placing the `k`-th\n * object part at position `(y, x)`.\n *\n * @param offsets 3-D tensor with shape `[height, width, numParts * 2]`.\n * The value of [offsets[y, x, k], offsets[y, x, k + numParts]]` is the\n * short range offset vector of the `k`-th  object part at heatmap\n * position `(y, x)`.\n *\n * @param displacementsFwd 3-D tensor of shape\n * `[height, width, 2 * num_edges]`, where `num_edges = num_parts - 1` is the\n * number of edges (parent-child pairs) in the tree. It contains the forward\n * displacements between consecutive part from the root towards the leaves.\n *\n * @param displacementsBwd 3-D tensor of shape\n * `[height, width, 2 * num_edges]`, where `num_edges = num_parts - 1` is the\n * number of edges (parent-child pairs) in the tree. It contains the backward\n * displacements between consecutive part from the root towards the leaves.\n *\n * @param outputStride The output stride that was used when feed-forwarding\n * through the PoseNet model.  Must be 32, 16, or 8.\n *\n * @param maxPoseDetections Maximum number of returned instance detections per\n * image.\n *\n * @param scoreThreshold Only return instance detections that have root part\n * score greater or equal to this value. Defaults to 0.5.\n *\n * @param nmsRadius Non-maximum suppression part distance. It needs to be\n * strictly positive. Two parts suppress each other if they are less than\n * `nmsRadius` pixels away. Defaults to 20.\n *\n * @return An array of poses and their scores, each containing keypoints and\n * the corresponding keypoint scores.\n */\nexport function decodeMultiplePoses(\n    scoresBuffer: TensorBuffer3D, offsetsBuffer: TensorBuffer3D,\n    displacementsFwdBuffer: TensorBuffer3D,\n    displacementsBwdBuffer: TensorBuffer3D, outputStride: number,\n    maxPoseDetections: number, scoreThreshold = 0.5, nmsRadius = 20): Pose[] {\n  const poses: Pose[] = [];\n\n  const queue = buildPartWithScoreQueue(\n      scoreThreshold, kLocalMaximumRadius, scoresBuffer);\n\n  const squaredNmsRadius = nmsRadius * nmsRadius;\n\n  // Generate at most maxDetections object instances per image in\n  // decreasing root part score order.\n  while (poses.length < maxPoseDetections && !queue.empty()) {\n    // The top element in the queue is the next root candidate.\n    const root = queue.dequeue();\n\n    // Part-based non-maximum suppression: We reject a root candidate if it\n    // is within a disk of `nmsRadius` pixels from the corresponding part of\n    // a previously detected instance.\n    const rootImageCoords =\n        getImageCoords(root.part, outputStride, offsetsBuffer);\n    if (withinNmsRadiusOfCorrespondingPoint(\n            poses, squaredNmsRadius, rootImageCoords, root.part.id)) {\n      continue;\n    }\n\n    // Start a new detection instance at the position of the root.\n    const keypoints = decodePose(\n        root, scoresBuffer, offsetsBuffer, outputStride, displacementsFwdBuffer,\n        displacementsBwdBuffer);\n\n    const score = getInstanceScore(poses, squaredNmsRadius, keypoints);\n\n    poses.push({keypoints, score});\n  }\n\n  return poses;\n}\n","/**\n * @license\n * Copyright 2019 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport * as tf from '@tensorflow/tfjs-core';\n\nimport {BaseModel} from './base_model';\n\nconst imageNetMean = [-123.15, -115.90, -103.06];\n\nexport class ResNet extends BaseModel {\n  preprocessInput(input: tf.Tensor3D): tf.Tensor3D {\n    return tf.add(input, imageNetMean);\n  }\n\n  nameOutputResults(results: tf.Tensor3D[]) {\n    const [\n      displacementBwd,\n      displacementFwd,\n      heatmap,\n      longOffsets,\n      offsets,\n      partHeatmaps,\n      segmentation,\n      partOffsets,\n  ] = results;\n    return {\n      offsets,\n      segmentation,\n      partHeatmaps,\n      longOffsets,\n      heatmap,\n      displacementFwd,\n      displacementBwd,\n      partOffsets\n    };\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nconst RESNET50_BASE_URL =\n    'https://storage.googleapis.com/tfjs-models/savedmodel/bodypix/resnet50/';\nconst MOBILENET_BASE_URL =\n    'https://storage.googleapis.com/tfjs-models/savedmodel/bodypix/mobilenet/';\n\n// The BodyPix 2.0 ResNet50 models use the latest TensorFlow.js 1.0 model\n// format.\nexport function resNet50SavedModel(stride: number, quantBytes: number): string {\n  const graphJson = `model-stride${stride}.json`;\n  // quantBytes=4 corresponding to the non-quantized full-precision SavedModel.\n  if (quantBytes === 4) {\n    return RESNET50_BASE_URL + `float/` + graphJson;\n  } else {\n    return RESNET50_BASE_URL + `quant${quantBytes}/` + graphJson;\n  }\n}\n\n// The BodyPix 2.0 MobileNetV1 models use the latest TensorFlow.js 1.0 model\n// format.\nexport function mobileNetSavedModel(\n    stride: number, multiplier: number, quantBytes: number): string {\n  const toStr: {[key: number]: string} = {1.0: '100', 0.75: '075', 0.50: '050'};\n  const graphJson = `model-stride${stride}.json`;\n  // quantBytes=4 corresponding to the non-quantized full-precision SavedModel.\n  if (quantBytes === 4) {\n    return MOBILENET_BASE_URL + `float/${toStr[multiplier]}/` + graphJson;\n  } else {\n    return MOBILENET_BASE_URL + `quant${quantBytes}/${toStr[multiplier]}/` +\n        graphJson;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\n\nimport * as tf from '@tensorflow/tfjs-core';\n\nimport {BodyPixInput, BodyPixOutputStride, Padding} from './types';\nimport {Pose, TensorBuffer3D} from './types';\nimport {BodyPixInternalResolution} from './types';\n\nfunction getSizeFromImageLikeElement(input: HTMLImageElement|\n                                     HTMLCanvasElement): [number, number] {\n  if (input.offsetHeight !== 0 && input.offsetWidth !== 0) {\n    return [input.offsetHeight, input.offsetWidth];\n  } else if (input.height != null && input.width != null) {\n    return [input.height, input.width];\n  } else {\n    throw new Error(\n        `HTMLImageElement must have height and width attributes set.`);\n  }\n}\n\nfunction getSizeFromVideoElement(input: HTMLVideoElement): [number, number] {\n  if (input.hasAttribute('height') && input.hasAttribute('width')) {\n    // Prioritizes user specified height and width.\n    // We can't test the .height and .width properties directly,\n    // because they evaluate to 0 if unset.\n    return [input.height, input.width];\n  } else {\n    return [input.videoHeight, input.videoWidth];\n  }\n}\n\nexport function getInputSize(input: BodyPixInput): [number, number] {\n  if ((typeof (HTMLCanvasElement) !== 'undefined' &&\n       input instanceof HTMLCanvasElement) ||\n      (typeof (HTMLImageElement) !== 'undefined' &&\n       input instanceof HTMLImageElement)) {\n    return getSizeFromImageLikeElement(input);\n  } else if (typeof (ImageData) !== 'undefined' && input instanceof ImageData) {\n    return [input.height, input.width];\n  } else if (\n      typeof (HTMLVideoElement) !== 'undefined' &&\n      input instanceof HTMLVideoElement) {\n    return getSizeFromVideoElement(input);\n  } else if (input instanceof tf.Tensor) {\n    return [input.shape[0], input.shape[1]];\n  } else {\n    throw new Error(`error: Unknown input type: ${input}.`);\n  }\n}\n\nfunction isValidInputResolution(\n    resolution: number, outputStride: number): boolean {\n  return (resolution - 1) % outputStride === 0;\n}\n\nexport function toValidInputResolution(\n    inputResolution: number, outputStride: BodyPixOutputStride): number {\n  if (isValidInputResolution(inputResolution, outputStride)) {\n    return inputResolution;\n  }\n\n  return Math.floor(inputResolution / outputStride) * outputStride + 1;\n}\n\nconst INTERNAL_RESOLUTION_STRING_OPTIONS = {\n  low: 'low',\n  medium: 'medium',\n  high: 'high',\n  full: 'full'\n};\n\nconst INTERNAL_RESOLUTION_PERCENTAGES = {\n  [INTERNAL_RESOLUTION_STRING_OPTIONS.low]: 0.25,\n  [INTERNAL_RESOLUTION_STRING_OPTIONS.medium]: 0.5,\n  [INTERNAL_RESOLUTION_STRING_OPTIONS.high]: 0.75,\n  [INTERNAL_RESOLUTION_STRING_OPTIONS.full]: 1.0\n};\n\nconst MIN_INTERNAL_RESOLUTION = 0.1;\nconst MAX_INTERNAL_RESOLUTION = 2.0;\n\nfunction toInternalResolutionPercentage(\n    internalResolution: BodyPixInternalResolution): number {\n  if (typeof internalResolution === 'string') {\n    const result = INTERNAL_RESOLUTION_PERCENTAGES[internalResolution];\n\n    tf.util.assert(\n        typeof result === 'number',\n        () => `string value of inputResolution must be one of ${\n            Object.values(INTERNAL_RESOLUTION_STRING_OPTIONS)\n                .join(',')} but was ${internalResolution}.`);\n    return result;\n  } else {\n    tf.util.assert(\n        typeof internalResolution === 'number' &&\n            internalResolution <= MAX_INTERNAL_RESOLUTION &&\n            internalResolution >= MIN_INTERNAL_RESOLUTION,\n        () =>\n            `inputResolution must be a string or number between ${\n                MIN_INTERNAL_RESOLUTION} and ${MAX_INTERNAL_RESOLUTION}, but ` +\n            `was ${internalResolution}`);\n\n    return internalResolution;\n  }\n}\n\nexport function toInputResolutionHeightAndWidth(\n    internalResolution: BodyPixInternalResolution,\n    outputStride: BodyPixOutputStride,\n    [inputHeight, inputWidth]: [number, number]): [number, number] {\n  const internalResolutionPercentage =\n      toInternalResolutionPercentage(internalResolution);\n\n  return [\n    toValidInputResolution(\n        inputHeight * internalResolutionPercentage, outputStride),\n    toValidInputResolution(\n        inputWidth * internalResolutionPercentage, outputStride)\n  ];\n}\n\nexport function toInputTensor(input: BodyPixInput) {\n  return input instanceof tf.Tensor ? input : tf.browser.fromPixels(input);\n}\n\nexport function resizeAndPadTo(\n    imageTensor: tf.Tensor3D, [targetH, targetW]: [number, number],\n    flipHorizontal = false): {\n  resizedAndPadded: tf.Tensor3D,\n  paddedBy: [[number, number], [number, number]]\n} {\n  const [height, width] = imageTensor.shape;\n\n  const targetAspect = targetW / targetH;\n  const aspect = width / height;\n\n  let resizeW: number;\n  let resizeH: number;\n  let padL: number;\n  let padR: number;\n  let padT: number;\n  let padB: number;\n\n  if (aspect > targetAspect) {\n    // resize to have the larger dimension match the shape.\n    resizeW = targetW;\n    resizeH = Math.ceil(resizeW / aspect);\n\n    const padHeight = targetH - resizeH;\n    padL = 0;\n    padR = 0;\n    padT = Math.floor(padHeight / 2);\n    padB = targetH - (resizeH + padT);\n  } else {\n    resizeH = targetH;\n    resizeW = Math.ceil(targetH * aspect);\n\n    const padWidth = targetW - resizeW;\n    padL = Math.floor(padWidth / 2);\n    padR = targetW - (resizeW + padL);\n    padT = 0;\n    padB = 0;\n  }\n\n  const resizedAndPadded = tf.tidy(() => {\n    // resize to have largest dimension match image\n    let resized: tf.Tensor3D;\n    if (flipHorizontal) {\n      resized = tf.image.resizeBilinear(\n          tf.reverse(imageTensor, 1), [resizeH, resizeW]);\n    } else {\n      resized = tf.image.resizeBilinear(imageTensor, [resizeH, resizeW]);\n    }\n\n    const padded = tf.pad3d(resized, [[padT, padB], [padL, padR], [0, 0]]);\n\n    return padded;\n  });\n\n  return {resizedAndPadded, paddedBy: [[padT, padB], [padL, padR]]};\n}\n\nexport function scaleAndCropToInputTensorShape(\n    tensor: tf.Tensor3D,\n    [inputTensorHeight, inputTensorWidth]: [number, number],\n    [resizedAndPaddedHeight, resizedAndPaddedWidth]: [number, number],\n    [[padT, padB], [padL, padR]]: [[number, number], [number, number]],\n    applySigmoidActivation = false): tf.Tensor3D {\n  return tf.tidy(() => {\n    let inResizedAndPadded: tf.Tensor3D = tf.image.resizeBilinear(tensor,\n        [resizedAndPaddedHeight, resizedAndPaddedWidth], true);\n\n    if (applySigmoidActivation) {\n      inResizedAndPadded = tf.sigmoid(inResizedAndPadded);\n    }\n\n    return removePaddingAndResizeBack(\n        inResizedAndPadded, [inputTensorHeight, inputTensorWidth],\n        [[padT, padB], [padL, padR]]);\n  });\n}\n\nexport function removePaddingAndResizeBack(\n    resizedAndPadded: tf.Tensor3D,\n    [originalHeight, originalWidth]: [number, number],\n    [[padT, padB], [padL, padR]]: [[number, number], [number, number]]):\n    tf.Tensor3D {\n  return tf.tidy(() => {\n    const batchedImage: tf.Tensor4D = tf.expandDims(resizedAndPadded);\n    return tf.squeeze(tf.image\n        .cropAndResize(\n            batchedImage, [[\n              padT / (originalHeight + padT + padB - 1.0),\n              padL / (originalWidth + padL + padR - 1.0),\n              (padT + originalHeight - 1.0) /\n                  (originalHeight + padT + padB - 1.0),\n              (padL + originalWidth - 1.0) / (originalWidth + padL + padR - 1.0)\n            ]],\n            [0], [originalHeight, originalWidth]), [0]);\n  });\n}\n\nexport function resize2d(\n    tensor: tf.Tensor2D, resolution: [number, number],\n    nearestNeighbor?: boolean): tf.Tensor2D {\n  return tf.tidy(() => {\n    const batchedImage: tf.Tensor4D = tf.expandDims(tensor, 2);\n    return tf.squeeze(\n        tf.image.resizeBilinear(batchedImage, resolution, nearestNeighbor));\n  });\n}\n\nexport function padAndResizeTo(\n    input: BodyPixInput, [targetH, targetW]: [number, number]):\n    {resized: tf.Tensor3D, padding: Padding} {\n  const [height, width] = getInputSize(input);\n  const targetAspect = targetW / targetH;\n  const aspect = width / height;\n  let [padT, padB, padL, padR] = [0, 0, 0, 0];\n  if (aspect < targetAspect) {\n    // pads the width\n    padT = 0;\n    padB = 0;\n    padL = Math.round(0.5 * (targetAspect * height - width));\n    padR = Math.round(0.5 * (targetAspect * height - width));\n  } else {\n    // pads the height\n    padT = Math.round(0.5 * ((1.0 / targetAspect) * width - height));\n    padB = Math.round(0.5 * ((1.0 / targetAspect) * width - height));\n    padL = 0;\n    padR = 0;\n  }\n\n  const resized: tf.Tensor3D = tf.tidy(() => {\n    let imageTensor = toInputTensor(input);\n    imageTensor = tf.pad3d(imageTensor, [[padT, padB], [padL, padR], [0, 0]]);\n\n    return tf.image.resizeBilinear(imageTensor, [targetH, targetW]);\n  });\n\n  return {resized, padding: {top: padT, left: padL, right: padR, bottom: padB}};\n}\n\nexport async function toTensorBuffers3D(tensors: tf.Tensor3D[]):\n    Promise<TensorBuffer3D[]> {\n  return Promise.all(tensors.map(tensor => tensor.buffer()));\n}\n\nexport function scalePose(\n    pose: Pose, scaleY: number, scaleX: number, offsetY = 0,\n    offsetX = 0): Pose {\n  return {\n    score: pose.score,\n    keypoints: pose.keypoints.map(({score, part, position}) => ({\n                                    score,\n                                    part,\n                                    position: {\n                                      x: position.x * scaleX + offsetX,\n                                      y: position.y * scaleY + offsetY\n                                    }\n                                  }))\n  };\n}\n\nexport function scalePoses(\n    poses: Pose[], scaleY: number, scaleX: number, offsetY = 0, offsetX = 0) {\n  if (scaleX === 1 && scaleY === 1 && offsetY === 0 && offsetX === 0) {\n    return poses;\n  }\n  return poses.map(pose => scalePose(pose, scaleY, scaleX, offsetY, offsetX));\n}\n\nexport function flipPoseHorizontal(pose: Pose, imageWidth: number): Pose {\n  return {\n    score: pose.score,\n    keypoints: pose.keypoints.map(\n        ({score, part, position}) => ({\n          score,\n          part,\n          position: {x: imageWidth - 1 - position.x, y: position.y}\n        }))\n  };\n}\n\nexport function flipPosesHorizontal(poses: Pose[], imageWidth: number) {\n  if (imageWidth <= 0) {\n    return poses;\n  }\n  return poses.map(pose => flipPoseHorizontal(pose, imageWidth));\n}\n\nexport function scaleAndFlipPoses(\n    poses: Pose[], [height, width]: [number, number],\n    [inputResolutionHeight, inputResolutionWidth]: [number, number],\n    padding: Padding, flipHorizontal: boolean): Pose[] {\n  const scaleY =\n      (height + padding.top + padding.bottom) / (inputResolutionHeight);\n  const scaleX =\n      (width + padding.left + padding.right) / (inputResolutionWidth);\n\n  const scaledPoses =\n      scalePoses(poses, scaleY, scaleX, -padding.top, -padding.left);\n\n  if (flipHorizontal) {\n    return flipPosesHorizontal(scaledPoses, width);\n  } else {\n    return scaledPoses;\n  }\n}\n","\n/**\n * @license\n * Copyright 2019 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport * as tfconv from '@tensorflow/tfjs-converter';\nimport * as tf from '@tensorflow/tfjs-core';\n\nimport {BaseModel} from './base_model';\nimport {decodeOnlyPartSegmentation, decodePartSegmentation, toMaskTensor} from './decode_part_map';\nimport {MobileNet} from './mobilenet';\nimport {decodePersonInstanceMasks, decodePersonInstancePartMasks} from './multi_person/decode_instance_masks';\nimport {decodeMultiplePoses} from './multi_person/decode_multiple_poses';\nimport {ResNet} from './resnet';\nimport {mobileNetSavedModel, resNet50SavedModel} from './saved_models';\nimport {BodyPixArchitecture, BodyPixInput, BodyPixInternalResolution, BodyPixMultiplier, BodyPixOutputStride, BodyPixQuantBytes, Padding} from './types';\nimport {PartSegmentation, PersonSegmentation, SemanticPartSegmentation, SemanticPersonSegmentation} from './types';\nimport {getInputSize, padAndResizeTo, scaleAndCropToInputTensorShape, scaleAndFlipPoses, toInputResolutionHeightAndWidth, toTensorBuffers3D} from './util';\n\nconst APPLY_SIGMOID_ACTIVATION = true;\nconst FLIP_POSES_AFTER_SCALING = false;\n\n/**\n * BodyPix model loading is configurable using the following config dictionary.\n *\n * `architecture`: BodyPixArchitecture. It determines which BodyPix architecture\n * to load. The supported architectures are: MobileNetV1 and ResNet50.\n *\n * `outputStride`: Specifies the output stride of the BodyPix model.\n * The smaller the value, the larger the output resolution, and more accurate\n * the model at the cost of speed. Set this to a larger value to increase speed\n * at the cost of accuracy. Stride 32 is supported for ResNet and\n * stride 8,16,32 are supported for various MobileNetV1 models.\n *\n * `multiplier`: An optional number with values: 1.01, 1.0, 0.75, or\n * 0.50. The value is used only by MobileNet architecture. It is the float\n * multiplier for the depth (number of channels) for all convolution ops.\n * The larger the value, the larger the size of the layers, and more accurate\n * the model at the cost of speed. Set this to a smaller value to increase speed\n * at the cost of accuracy.\n *\n * `modelUrl`: An optional string that specifies custom url of the model. This\n * is useful for area/countries that don't have access to the model hosted on\n * GCP.\n *\n * `quantBytes`: An optional number with values: 1, 2, or 4.  This parameter\n * affects weight quantization in the models. The available options are\n * 1 byte, 2 bytes, and 4 bytes. The higher the value, the larger the model size\n * and thus the longer the loading time, the lower the value, the shorter the\n * loading time but lower the accuracy.\n */\nexport interface ModelConfig {\n  architecture: BodyPixArchitecture;\n  outputStride: BodyPixOutputStride;\n  multiplier?: BodyPixMultiplier;\n  modelUrl?: string;\n  quantBytes?: BodyPixQuantBytes;\n}\n\n// The default configuration for loading MobileNetV1 based BodyPix.\n//\n// (And for references, the default configuration for loading ResNet\n// based PoseNet is also included).\n//\n// ```\n// const RESNET_CONFIG = {\n//   architecture: 'ResNet50',\n//   outputStride: 32,\n//   quantBytes: 4,\n// } as ModelConfig;\n// ```\n\nconst MOBILENET_V1_CONFIG = {\n  architecture: 'MobileNetV1',\n  outputStride: 16,\n  quantBytes: 4,\n  multiplier: 0.75,\n} as ModelConfig;\n\nconst VALID_ARCHITECTURE: BodyPixArchitecture[] = ['MobileNetV1', 'ResNet50'];\nconst VALID_STRIDE: {[id: string]: BodyPixOutputStride[]} = {\n  'MobileNetV1': [8, 16, 32],\n  'ResNet50': [32, 16]\n};\nconst VALID_MULTIPLIER: {[id: string]: BodyPixMultiplier[]} = {\n  'MobileNetV1': [0.50, 0.75, 1.0],\n  'ResNet50': [1.0]\n};\nconst VALID_QUANT_BYTES: BodyPixQuantBytes[] = [1, 2, 4];\n\nfunction validateModelConfig(config: ModelConfig): ModelConfig {\n  config = config || MOBILENET_V1_CONFIG;\n\n  if (config.architecture == null) {\n    config.architecture = 'MobileNetV1';\n  }\n  if (VALID_ARCHITECTURE.indexOf(config.architecture) < 0) {\n    throw new Error(\n        `Invalid architecture ${config.architecture}. ` +\n        `Should be one of ${VALID_ARCHITECTURE}`);\n  }\n  if (config.outputStride == null) {\n    config.outputStride = 16;\n  }\n  if (VALID_STRIDE[config.architecture].indexOf(config.outputStride) < 0) {\n    throw new Error(\n        `Invalid outputStride ${config.outputStride}. ` +\n        `Should be one of ${VALID_STRIDE[config.architecture]} ` +\n        `for architecture ${config.architecture}.`);\n  }\n\n  if (config.multiplier == null) {\n    config.multiplier = 1.0;\n  }\n  if (VALID_MULTIPLIER[config.architecture].indexOf(config.multiplier) < 0) {\n    throw new Error(\n        `Invalid multiplier ${config.multiplier}. ` +\n        `Should be one of ${VALID_MULTIPLIER[config.architecture]} ` +\n        `for architecture ${config.architecture}.`);\n  }\n\n  if (config.quantBytes == null) {\n    config.quantBytes = 4;\n  }\n  if (VALID_QUANT_BYTES.indexOf(config.quantBytes) < 0) {\n    throw new Error(\n        `Invalid quantBytes ${config.quantBytes}. ` +\n        `Should be one of ${VALID_QUANT_BYTES} ` +\n        `for architecture ${config.architecture}.`);\n  }\n\n  return config;\n}\n\n/**\n * BodyPix inference is configurable using the following config dictionary.\n *\n * `flipHorizontal`: If the left-right keypoint of poses/part segmentation\n * should be flipped/mirrored horizontally. This should be set to true for\n * videos where the video is by default flipped horizontally (i.e. a webcam),\n * and you want the person & body part segmentation to be returned in the proper\n * orientation.\n *\n * `internalResolution`: Defaults to 'medium'. The internal resolution\n * percentage that the input is resized to before inference. The larger the\n * internalResolution the more accurate the model at the cost of slower\n * prediction times. Available values are 'low', 'medium', 'high', 'full', or a\n * percentage value between 0 and 1. The values 'low', 'medium', 'high', and\n * 'full' map to 0.25, 0.5, 0.75, and 1.0 correspondingly.\n *\n * `segmentationThreshold`: The minimum that segmentation values must\n * have to be considered part of the person. Affects the generation of the\n * segmentation mask. More specifically, it is the threshold used to binarize\n * the intermediate person segmentation probability. The probability of each\n * pixel belongs to a person is in range [0, 1]. If the probability is greater\n * than the `segmentationThreshold`, it will be set to 1 otherwise 0.\n *\n */\nexport interface InferenceConfig {\n  flipHorizontal?: boolean;\n  internalResolution?: BodyPixInternalResolution;\n  segmentationThreshold?: number;\n}\n\n/**\n * Person Inference Config\n *\n * `maxDetections`: Defaults to 10. Maximum number of person pose detections per\n * image.\n *\n * `scoreThreshold`: Defaults to 0.4. Only return person pose that have root\n * part score greater or equal to this value.\n *\n * `nmsRadius`: Defaults to 20. Non-maximum suppression part distance in pixels.\n * It needs to be strictly positive. Two pose keypoints suppress each other if\n * they are less than `nmsRadius` pixels away.\n */\nexport interface PersonInferenceConfig extends InferenceConfig {\n  maxDetections?: number;\n  scoreThreshold?: number;\n  nmsRadius?: number;\n}\n\n/**\n * Multiple Person Instance Inference Config\n *\n * `maxDetections`: Defaults to 10. Maximum number of returned instance\n * segmentation and pose detections per image.\n *\n * `scoreThreshold`: Defaults to 0.4. Only returns and uses person\n * poses for instance segmentation assignment when the pose has root part score\n * greater or equal to this value.\n *\n * `nmsRadius`: Defaults to 20. Non-maximum suppression part distance in pixels.\n * It needs to be strictly positive. Two parts suppress each other if they are\n * less than `nmsRadius` pixels away.\n *\n * `minKeypointScore`: Default to 0.3. Keypoints above the score are used\n * for matching and assigning segmentation mask to each person.\n *\n * `refineSteps`: Default to 10. The number of refinement steps used when\n * assigning the instance segmentation. It needs to be strictly positive. The\n * larger the higher the accuracy and slower the inference.\n *\n */\nexport interface MultiPersonInstanceInferenceConfig extends InferenceConfig {\n  maxDetections?: number;\n  scoreThreshold?: number;\n  nmsRadius?: number;\n  minKeypointScore?: number;\n  refineSteps?: number;\n}\n\nexport const PERSON_INFERENCE_CONFIG: PersonInferenceConfig = {\n  flipHorizontal: false,\n  internalResolution: 'medium',\n  segmentationThreshold: 0.7,\n  maxDetections: 10,\n  scoreThreshold: 0.4,\n  nmsRadius: 20,\n};\n\nexport const MULTI_PERSON_INSTANCE_INFERENCE_CONFIG:\n    MultiPersonInstanceInferenceConfig = {\n      flipHorizontal: false,\n      internalResolution: 'medium',\n      segmentationThreshold: 0.7,\n      maxDetections: 10,\n      scoreThreshold: 0.4,\n      nmsRadius: 20,\n      minKeypointScore: 0.3,\n      refineSteps: 10\n    };\n\nfunction validatePersonInferenceConfig(config: PersonInferenceConfig) {\n  const {segmentationThreshold, maxDetections, scoreThreshold, nmsRadius} =\n      config;\n\n  if (segmentationThreshold < 0.0 || segmentationThreshold > 1.0) {\n    throw new Error(\n        `segmentationThreshold ${segmentationThreshold}. ` +\n        `Should be in range [0.0, 1.0]`);\n  }\n\n  if (maxDetections <= 0) {\n    throw new Error(\n        `Invalid maxDetections ${maxDetections}. ` +\n        `Should be > 0`);\n  }\n\n  if (scoreThreshold < 0.0 || scoreThreshold > 1.0) {\n    throw new Error(\n        `Invalid scoreThreshold ${scoreThreshold}. ` +\n        `Should be in range [0.0, 1.0]`);\n  }\n\n  if (nmsRadius <= 0) {\n    throw new Error(`Invalid nmsRadius ${nmsRadius}.`);\n  }\n}\n\nfunction validateMultiPersonInstanceInferenceConfig(\n    config: MultiPersonInstanceInferenceConfig) {\n  const {\n    segmentationThreshold,\n    maxDetections,\n    scoreThreshold,\n    nmsRadius,\n    minKeypointScore,\n    refineSteps\n  } = config;\n\n  if (segmentationThreshold < 0.0 || segmentationThreshold > 1.0) {\n    throw new Error(\n        `segmentationThreshold ${segmentationThreshold}. ` +\n        `Should be in range [0.0, 1.0]`);\n  }\n\n  if (maxDetections <= 0) {\n    throw new Error(\n        `Invalid maxDetections ${maxDetections}. ` +\n        `Should be > 0`);\n  }\n\n  if (scoreThreshold < 0.0 || scoreThreshold > 1.0) {\n    throw new Error(\n        `Invalid scoreThreshold ${scoreThreshold}. ` +\n        `Should be in range [0.0, 1.0]`);\n  }\n\n  if (nmsRadius <= 0) {\n    throw new Error(`Invalid nmsRadius ${nmsRadius}.`);\n  }\n\n  if (minKeypointScore < 0 || minKeypointScore > 1) {\n    throw new Error(\n        `Invalid minKeypointScore ${minKeypointScore}.` +\n        `Should be in range [0.0, 1.0]`);\n  }\n\n  if (refineSteps <= 0 || refineSteps > 20) {\n    throw new Error(\n        `Invalid refineSteps ${refineSteps}.` +\n        `Should be in range [1, 20]`);\n  }\n}\n\nexport class BodyPix {\n  baseModel: BaseModel;\n\n  constructor(net: BaseModel) {\n    this.baseModel = net;\n  }\n\n  private predictForPersonSegmentation(input: tf.Tensor3D): {\n    segmentLogits: tf.Tensor3D,\n    heatmapScores: tf.Tensor3D,\n    offsets: tf.Tensor3D,\n    displacementFwd: tf.Tensor3D,\n    displacementBwd: tf.Tensor3D,\n  } {\n    const {\n      segmentation,\n      heatmapScores,\n      offsets,\n      displacementFwd,\n      displacementBwd,\n    } = this.baseModel.predict(input);\n    return {\n      segmentLogits: segmentation,\n      heatmapScores,\n      offsets,\n      displacementFwd,\n      displacementBwd,\n    };\n  }\n\n  private predictForPersonSegmentationAndPart(input: tf.Tensor3D): {\n    segmentLogits: tf.Tensor3D,\n    partHeatmapLogits: tf.Tensor3D,\n    heatmapScores: tf.Tensor3D,\n    offsets: tf.Tensor3D,\n    displacementFwd: tf.Tensor3D,\n    displacementBwd: tf.Tensor3D,\n  } {\n    const {\n      segmentation,\n      partHeatmaps,\n      heatmapScores,\n      offsets,\n      displacementFwd,\n      displacementBwd\n    } = this.baseModel.predict(input);\n    return {\n      segmentLogits: segmentation,\n      partHeatmapLogits: partHeatmaps,\n      heatmapScores,\n      offsets,\n      displacementFwd,\n      displacementBwd,\n    };\n  }\n\n  private predictForMultiPersonInstanceSegmentationAndPart(input: tf.Tensor3D):\n      {\n        segmentLogits: tf.Tensor3D,\n        longOffsets: tf.Tensor3D,\n        heatmapScores: tf.Tensor3D,\n        offsets: tf.Tensor3D,\n        displacementFwd: tf.Tensor3D,\n        displacementBwd: tf.Tensor3D,\n        partHeatmaps: tf.Tensor3D\n      } {\n    const {\n      segmentation,\n      longOffsets,\n      heatmapScores,\n      offsets,\n      displacementFwd,\n      displacementBwd,\n      partHeatmaps,\n    } = this.baseModel.predict(input);\n    return {\n      segmentLogits: segmentation,\n      longOffsets,\n      heatmapScores,\n      offsets,\n      displacementFwd,\n      displacementBwd,\n      partHeatmaps\n    };\n  }\n\n  /**\n   * Given an image with people, returns a dictionary of all intermediate\n   * tensors including: 1) a binary array with 1 for the pixels that are part of\n   * the person, and 0 otherwise, 2) heatmapScores, 3) offsets, and 4) paddings.\n   *\n   * @param input ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement)\n   * The input image to feed through the network.\n   *\n   * @param internalResolution Defaults to 'medium'. The internal resolution\n   * that the input is resized to before inference. The larger the\n   * internalResolution the more accurate the model at the cost of slower\n   * prediction times. Available values are 'low', 'medium', 'high', 'full', or\n   * a percentage value between 0 and 1. The values 'low', 'medium', 'high', and\n   * 'full' map to 0.25, 0.5, 0.75, and 1.0 correspondingly.\n   *\n   * @param segmentationThreshold The minimum that segmentation values must have\n   * to be considered part of the person. Affects the generation of the\n   * segmentation mask.\n   *\n   * @return A dictionary containing `segmentation`, `heatmapScores`, `offsets`,\n   * and `padding`:\n   * - `segmentation`: A 2d Tensor with 1 for the pixels that are part of the\n   * person, and 0 otherwise. The width and height correspond to the same\n   * dimensions of the input image.\n   * - `heatmapScores`: A 3d Tensor of the keypoint heatmaps used by\n   * pose estimation decoding.\n   * - `offsets`: A 3d Tensor of the keypoint offsets used by pose\n   * estimation decoding.\n   * - `displacementFwd`: A 3d Tensor of the keypoint forward displacement used\n   * by pose estimation decoding.\n   * - `displacementBwd`: A 3d Tensor of the keypoint backward displacement used\n   * by pose estimation decoding.\n   * - `padding`: The padding (unit pixels) being applied to the input image\n   * before it is fed into the model.\n   */\n  segmentPersonActivation(\n      input: BodyPixInput, internalResolution: BodyPixInternalResolution,\n      segmentationThreshold = 0.5): {\n    segmentation: tf.Tensor2D,\n    heatmapScores: tf.Tensor3D,\n    offsets: tf.Tensor3D,\n    displacementFwd: tf.Tensor3D,\n    displacementBwd: tf.Tensor3D,\n    padding: Padding,\n    internalResolutionHeightAndWidth: [number, number]\n  } {\n    const [height, width] = getInputSize(input);\n    const internalResolutionHeightAndWidth = toInputResolutionHeightAndWidth(\n        internalResolution, this.baseModel.outputStride, [height, width]);\n    const {resized, padding} =\n        padAndResizeTo(input, internalResolutionHeightAndWidth);\n\n    const {\n      segmentation,\n      heatmapScores,\n      offsets,\n      displacementFwd,\n      displacementBwd\n    } = tf.tidy(() => {\n      const {\n        segmentLogits,\n        heatmapScores,\n        offsets,\n        displacementFwd,\n        displacementBwd\n      } = this.predictForPersonSegmentation(resized);\n\n      const [resizedHeight, resizedWidth] = resized.shape;\n\n      const scaledSegmentScores = scaleAndCropToInputTensorShape(\n          segmentLogits, [height, width], [resizedHeight, resizedWidth],\n          [[padding.top, padding.bottom], [padding.left, padding.right]],\n          APPLY_SIGMOID_ACTIVATION);\n\n      return {\n        segmentation: toMaskTensor(\n            tf.squeeze(scaledSegmentScores), segmentationThreshold),\n        heatmapScores,\n        offsets,\n        displacementFwd,\n        displacementBwd,\n      };\n    });\n    resized.dispose();\n    return {\n      segmentation,\n      heatmapScores,\n      offsets,\n      displacementFwd,\n      displacementBwd,\n      padding,\n      internalResolutionHeightAndWidth\n    };\n  }\n\n  /**\n   * Given an image with many people, returns a PersonSegmentation dictionary\n   * that contains the segmentation mask for all people and a single pose.\n   *\n   * Note: The segmentation mask returned by this method covers all people but\n   * the pose works well for one person. If you want to estimate instance-level\n   * multiple person segmentation & pose for each person, use\n   * `segmentMultiPerson` instead.\n   *\n   * @param input ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement)\n   * The input image to feed through the network.\n   *\n   * @param config PersonInferenceConfig object that contains\n   * parameters for the BodyPix inference using person decoding.\n   *\n   * @return A SemanticPersonSegmentation dictionary that contains height,\n   * width, the flattened binary segmentation mask and the poses for all people.\n   * The width and height correspond to the same dimensions of the input image.\n   * - `height`: The height of the segmentation data in pixel unit.\n   * - `width`: The width of the segmentation data in pixel unit.\n   * - `data`: The flattened Uint8Array of segmentation data. 1 means the pixel\n   * belongs to a person and 0 means the pixel doesn't belong to a person. The\n   * size of the array is equal to `height` x `width` in row-major order.\n   * - `allPoses`: The 2d poses of all people.\n   */\n  async segmentPerson(\n      input: BodyPixInput,\n      config: PersonInferenceConfig = PERSON_INFERENCE_CONFIG):\n      Promise<SemanticPersonSegmentation> {\n    config = {...PERSON_INFERENCE_CONFIG, ...config};\n\n    validatePersonInferenceConfig(config);\n\n    const {\n      segmentation,\n      heatmapScores,\n      offsets,\n      displacementFwd,\n      displacementBwd,\n      padding,\n      internalResolutionHeightAndWidth\n    } =\n        this.segmentPersonActivation(\n            input, config.internalResolution, config.segmentationThreshold);\n\n    const [height, width] = segmentation.shape;\n\n    const result = await segmentation.data() as Uint8Array;\n    segmentation.dispose();\n\n    const tensorBuffers = await toTensorBuffers3D(\n        [heatmapScores, offsets, displacementFwd, displacementBwd]);\n    const [scoresBuf, offsetsBuf, displacementsFwdBuf, displacementsBwdBuf] =\n        tensorBuffers;\n\n    let poses = decodeMultiplePoses(\n        scoresBuf, offsetsBuf, displacementsFwdBuf, displacementsBwdBuf,\n        this.baseModel.outputStride, config.maxDetections,\n        config.scoreThreshold, config.nmsRadius);\n\n    poses = scaleAndFlipPoses(\n        poses, [height, width], internalResolutionHeightAndWidth, padding,\n        FLIP_POSES_AFTER_SCALING);\n\n    heatmapScores.dispose();\n    offsets.dispose();\n    displacementFwd.dispose();\n    displacementBwd.dispose();\n\n    return {height, width, data: result, allPoses: poses};\n  }\n\n  /**\n   * Given an image with multiple people, returns an *array* of\n   * PersonSegmentation object. Each element in the array corresponding to one\n   * of the people in the input image. In other words, it predicts\n   * instance-level multiple person segmentation & pose for each person.\n   *\n   * The model does standard ImageNet pre-processing before inferring through\n   * the model. The image pixels should have values [0-255].\n   *\n   * @param input\n   * ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement) The input\n   * image to feed through the network.\n   *\n   * @param config MultiPersonInferenceConfig object that contains\n   * parameters for the BodyPix inference using multi-person decoding.\n   *\n   * @return An array of PersonSegmentation object, each containing a width,\n   * height, a binary array (1 for the pixels that are part of the\n   * person, and 0 otherwise) and 2D pose. The array size corresponds to the\n   * number of pixels in the image. The width and height correspond to the\n   * dimensions of the image the binary array is shaped to, which are the same\n   * dimensions of the input image.\n   */\n  async segmentMultiPerson(\n      input: BodyPixInput,\n      config: MultiPersonInstanceInferenceConfig =\n          MULTI_PERSON_INSTANCE_INFERENCE_CONFIG):\n      Promise<PersonSegmentation[]> {\n    config = {...MULTI_PERSON_INSTANCE_INFERENCE_CONFIG, ...config};\n    validateMultiPersonInstanceInferenceConfig(config);\n    const [height, width] = getInputSize(input);\n    const internalResolutionHeightAndWidth = toInputResolutionHeightAndWidth(\n        config.internalResolution, this.baseModel.outputStride,\n        [height, width]);\n\n    const {resized, padding} =\n        padAndResizeTo(input, internalResolutionHeightAndWidth);\n    const {\n      segmentation,\n      longOffsets,\n      heatmapScoresRaw,\n      offsetsRaw,\n      displacementFwdRaw,\n      displacementBwdRaw,\n    } = tf.tidy(() => {\n      const {\n        segmentLogits,\n        longOffsets,\n        heatmapScores,\n        offsets,\n        displacementFwd,\n        displacementBwd,\n      } = this.predictForMultiPersonInstanceSegmentationAndPart(resized);\n      const scaledSegmentScores = scaleAndCropToInputTensorShape(\n          segmentLogits, [height, width], internalResolutionHeightAndWidth,\n          [[padding.top, padding.bottom], [padding.left, padding.right]],\n          APPLY_SIGMOID_ACTIVATION);\n      const longOffsetsResized = false;\n      let scaledLongOffsets;\n      if (longOffsetsResized) {\n        scaledLongOffsets = scaleAndCropToInputTensorShape(\n            longOffsets, [height, width], internalResolutionHeightAndWidth,\n            [[padding.top, padding.bottom], [padding.left, padding.right]],\n            APPLY_SIGMOID_ACTIVATION);\n      } else {\n        scaledLongOffsets = longOffsets;\n      }\n\n      const segmentation = toMaskTensor(\n          tf.squeeze(scaledSegmentScores), config.segmentationThreshold);\n\n      return {\n        segmentation,\n        longOffsets: scaledLongOffsets,\n        heatmapScoresRaw: heatmapScores,\n        offsetsRaw: offsets,\n        displacementFwdRaw: displacementFwd,\n        displacementBwdRaw: displacementBwd,\n      };\n    });\n\n    const tensorBuffers = await toTensorBuffers3D(\n        [heatmapScoresRaw, offsetsRaw, displacementFwdRaw, displacementBwdRaw]);\n    const [scoresBuf, offsetsBuf, displacementsFwdBuf, displacementsBwdBuf] =\n        tensorBuffers;\n\n    let poses = decodeMultiplePoses(\n        scoresBuf, offsetsBuf, displacementsFwdBuf, displacementsBwdBuf,\n        this.baseModel.outputStride, config.maxDetections,\n        config.scoreThreshold, config.nmsRadius);\n\n    poses = scaleAndFlipPoses(\n        poses, [height, width], internalResolutionHeightAndWidth, padding,\n        FLIP_POSES_AFTER_SCALING);\n\n    const instanceMasks = await decodePersonInstanceMasks(\n        segmentation, longOffsets, poses, height, width,\n        this.baseModel.outputStride, internalResolutionHeightAndWidth, padding,\n        config.scoreThreshold, config.refineSteps, config.minKeypointScore,\n        config.maxDetections);\n\n    resized.dispose();\n    segmentation.dispose();\n    longOffsets.dispose();\n    heatmapScoresRaw.dispose();\n    offsetsRaw.dispose();\n    displacementFwdRaw.dispose();\n    displacementBwdRaw.dispose();\n\n    return instanceMasks;\n  }\n\n  /**\n   * Given an image with many people, returns a dictionary containing: height,\n   * width, a tensor with a part id from 0-24 for the pixels that are\n   * part of a corresponding body part, and -1 otherwise. This does standard\n   * ImageNet pre-processing before inferring through the model.  The image\n   * should pixels should have values [0-255].\n   *\n   * @param input ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement)\n   * The input image to feed through the network.\n   *\n   * @param internalResolution Defaults to 'medium'. The internal resolution\n   * percentage that the input is resized to before inference. The larger the\n   * internalResolution the more accurate the model at the cost of slower\n   * prediction times. Available values are 'low', 'medium', 'high', 'full', or\n   * a percentage value between 0 and 1. The values 'low', 'medium', 'high', and\n   * 'full' map to 0.25, 0.5, 0.75, and 1.0 correspondingly.\n   *\n   * @param segmentationThreshold The minimum that segmentation values must have\n   * to be considered part of the person.  Affects the clipping of the colored\n   * part image.\n   *\n   * @return  A dictionary containing `partSegmentation`, `heatmapScores`,\n   * `offsets`, and `padding`:\n   * - `partSegmentation`: A 2d Tensor with a part id from 0-24 for\n   * the pixels that are part of a corresponding body part, and -1 otherwise.\n   * - `heatmapScores`: A 3d Tensor of the keypoint heatmaps used by\n   * single-person pose estimation decoding.\n   * - `offsets`: A 3d Tensor of the keypoint offsets used by single-person pose\n   * estimation decoding.\n   * - `displacementFwd`: A 3d Tensor of the keypoint forward displacement\n   * used by pose estimation decoding.\n   * - `displacementBwd`: A 3d Tensor of the keypoint backward displacement used\n   * by pose estimation decoding.\n   * - `padding`: The padding (unit pixels) being applied to the input image\n   * before it is fed into the model.\n   */\n  segmentPersonPartsActivation(\n      input: BodyPixInput, internalResolution: BodyPixInternalResolution,\n      segmentationThreshold = 0.5): {\n    partSegmentation: tf.Tensor2D,\n    heatmapScores: tf.Tensor3D,\n    offsets: tf.Tensor3D,\n    displacementFwd: tf.Tensor3D,\n    displacementBwd: tf.Tensor3D,\n    padding: Padding,\n    internalResolutionHeightAndWidth: [number, number]\n  } {\n    const [height, width] = getInputSize(input);\n    const internalResolutionHeightAndWidth = toInputResolutionHeightAndWidth(\n        internalResolution, this.baseModel.outputStride, [height, width]);\n    const {\n      resized,\n      padding,\n    } = padAndResizeTo(input, internalResolutionHeightAndWidth);\n\n    const {\n      partSegmentation,\n      heatmapScores,\n      offsets,\n      displacementFwd,\n      displacementBwd\n    } = tf.tidy(() => {\n      const {\n        segmentLogits,\n        partHeatmapLogits,\n        heatmapScores,\n        offsets,\n        displacementFwd,\n        displacementBwd\n      } = this.predictForPersonSegmentationAndPart(resized);\n\n      const [resizedHeight, resizedWidth] = resized.shape;\n\n      const scaledSegmentScores = scaleAndCropToInputTensorShape(\n          segmentLogits, [height, width], [resizedHeight, resizedWidth],\n          [[padding.top, padding.bottom], [padding.left, padding.right]],\n          APPLY_SIGMOID_ACTIVATION);\n\n      const scaledPartHeatmapScore = scaleAndCropToInputTensorShape(\n          partHeatmapLogits, [height, width], [resizedHeight, resizedWidth],\n          [[padding.top, padding.bottom], [padding.left, padding.right]],\n          APPLY_SIGMOID_ACTIVATION);\n      const segmentation =\n          toMaskTensor(tf.squeeze(scaledSegmentScores), segmentationThreshold);\n      return {\n        partSegmentation:\n            decodePartSegmentation(segmentation, scaledPartHeatmapScore),\n        heatmapScores,\n        offsets,\n        displacementFwd,\n        displacementBwd,\n      };\n    });\n    resized.dispose();\n    return {\n      partSegmentation,\n      heatmapScores,\n      offsets,\n      displacementFwd,\n      displacementBwd,\n      padding,\n      internalResolutionHeightAndWidth\n    };\n  }\n\n  /**\n   * Given an image with many people, returns a PartSegmentation dictionary that\n   * contains the body part segmentation mask for all people and a single pose.\n   *\n   * Note: The body part segmentation mask returned by this method covers all\n   * people but the pose works well when there is one person. If you want to\n   * estimate instance-level multiple person body part segmentation & pose for\n   * each person, use `segmentMultiPersonParts` instead.\n   *\n   * @param input ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement)\n   * The input image to feed through the network.\n   *\n   * @param config PersonInferenceConfig object that contains\n   * parameters for the BodyPix inference using single person decoding.\n   *\n   * @return A SemanticPartSegmentation dictionary that contains height, width,\n   * the flattened binary segmentation mask and the pose for the person. The\n   * width and height correspond to the same dimensions of the input image.\n   * - `height`: The height of the person part segmentation data in pixel unit.\n   * - `width`: The width of the person part segmentation data in pixel unit.\n   * - `data`: The flattened Int32Array of person part segmentation data with a\n   * part id from 0-24 for the pixels that are part of a corresponding body\n   * part, and -1 otherwise. The size of the array is equal to `height` x\n   * `width` in row-major order.\n   * - `allPoses`: The 2d poses of all people.\n   */\n  async segmentPersonParts(\n      input: BodyPixInput,\n      config: PersonInferenceConfig = PERSON_INFERENCE_CONFIG):\n      Promise<SemanticPartSegmentation> {\n    config = {...PERSON_INFERENCE_CONFIG, ...config};\n\n    validatePersonInferenceConfig(config);\n    const {\n      partSegmentation,\n      heatmapScores,\n      offsets,\n      displacementFwd,\n      displacementBwd,\n      padding,\n      internalResolutionHeightAndWidth\n    } =\n        this.segmentPersonPartsActivation(\n            input, config.internalResolution, config.segmentationThreshold);\n\n    const [height, width] = partSegmentation.shape;\n    const data = await partSegmentation.data() as Int32Array;\n    partSegmentation.dispose();\n\n    const tensorBuffers = await toTensorBuffers3D(\n        [heatmapScores, offsets, displacementFwd, displacementBwd]);\n    const [scoresBuf, offsetsBuf, displacementsFwdBuf, displacementsBwdBuf] =\n        tensorBuffers;\n\n    let poses = decodeMultiplePoses(\n        scoresBuf, offsetsBuf, displacementsFwdBuf, displacementsBwdBuf,\n        this.baseModel.outputStride, config.maxDetections,\n        config.scoreThreshold, config.nmsRadius);\n\n    poses = scaleAndFlipPoses(\n        poses, [height, width], internalResolutionHeightAndWidth, padding,\n        FLIP_POSES_AFTER_SCALING);\n\n    heatmapScores.dispose();\n    offsets.dispose();\n    displacementFwd.dispose();\n    displacementBwd.dispose();\n\n    return {height, width, data, allPoses: poses};\n  }\n\n  /**\n   * Given an image with multiple people, returns an *array* of PartSegmentation\n   * object. Each element in the array corresponding to one\n   * of the people in the input image. In other words, it predicts\n   * instance-level multiple person body part segmentation & pose for each\n   * person.\n   *\n   * This does standard ImageNet pre-processing before inferring through\n   * the model. The image pixels should have values [0-255].\n   *\n   * @param input\n   * ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement) The input\n   * image to feed through the network.\n   *\n   * @param config MultiPersonInferenceConfig object that contains\n   * parameters for the BodyPix inference using multi-person decoding.\n   *\n   * @return An array of PartSegmentation object, each containing a width,\n   * height, a flattened array (with part id from 0-24 for the pixels that are\n   * part of a corresponding body part, and -1 otherwise) and 2D pose. The width\n   * and height correspond to the dimensions of the image. Each flattened part\n   * segmentation array size is equal to `height` x `width`.\n   */\n  async segmentMultiPersonParts(\n      input: BodyPixInput,\n      config: MultiPersonInstanceInferenceConfig =\n          MULTI_PERSON_INSTANCE_INFERENCE_CONFIG): Promise<PartSegmentation[]> {\n    config = {...MULTI_PERSON_INSTANCE_INFERENCE_CONFIG, ...config};\n\n    validateMultiPersonInstanceInferenceConfig(config);\n    const [height, width] = getInputSize(input);\n    const internalResolutionHeightAndWidth = toInputResolutionHeightAndWidth(\n        config.internalResolution, this.baseModel.outputStride,\n        [height, width]);\n    const {resized, padding} =\n        padAndResizeTo(input, internalResolutionHeightAndWidth);\n    const {\n      segmentation,\n      longOffsets,\n      heatmapScoresRaw,\n      offsetsRaw,\n      displacementFwdRaw,\n      displacementBwdRaw,\n      partSegmentation,\n    } = tf.tidy(() => {\n      const {\n        segmentLogits,\n        longOffsets,\n        heatmapScores,\n        offsets,\n        displacementFwd,\n        displacementBwd,\n        partHeatmaps\n      } = this.predictForMultiPersonInstanceSegmentationAndPart(resized);\n\n      // decoding with scaling.\n      const scaledSegmentScores = scaleAndCropToInputTensorShape(\n          segmentLogits, [height, width], internalResolutionHeightAndWidth,\n          [[padding.top, padding.bottom], [padding.left, padding.right]],\n          APPLY_SIGMOID_ACTIVATION);\n\n      // decoding with scaling.\n      const scaledPartSegmentationScores = scaleAndCropToInputTensorShape(\n          partHeatmaps, [height, width], internalResolutionHeightAndWidth,\n          [[padding.top, padding.bottom], [padding.left, padding.right]],\n          APPLY_SIGMOID_ACTIVATION);\n\n      const scaledLongOffsets = longOffsets;\n      const segmentation = toMaskTensor(\n        tf.squeeze(scaledSegmentScores), config.segmentationThreshold);\n      const partSegmentation =\n          decodeOnlyPartSegmentation(scaledPartSegmentationScores);\n      return {\n        segmentation,\n        longOffsets: scaledLongOffsets,\n        heatmapScoresRaw: heatmapScores,\n        offsetsRaw: offsets,\n        displacementFwdRaw: displacementFwd,\n        displacementBwdRaw: displacementBwd,\n        partSegmentation\n      };\n    });\n\n    const tensorBuffers = await toTensorBuffers3D(\n        [heatmapScoresRaw, offsetsRaw, displacementFwdRaw, displacementBwdRaw]);\n    const [scoresBuf, offsetsBuf, displacementsFwdBuf, displacementsBwdBuf] =\n        tensorBuffers;\n\n    let poses = decodeMultiplePoses(\n        scoresBuf, offsetsBuf, displacementsFwdBuf, displacementsBwdBuf,\n        this.baseModel.outputStride, config.maxDetections,\n        config.scoreThreshold, config.nmsRadius);\n\n    poses = scaleAndFlipPoses(\n        poses, [height, width], internalResolutionHeightAndWidth, padding,\n        FLIP_POSES_AFTER_SCALING);\n\n    const instanceMasks = await decodePersonInstancePartMasks(\n        segmentation, longOffsets, partSegmentation, poses, height, width,\n        this.baseModel.outputStride, internalResolutionHeightAndWidth, padding,\n        config.scoreThreshold, config.refineSteps, config.minKeypointScore,\n        config.maxDetections);\n\n    resized.dispose();\n    segmentation.dispose();\n    longOffsets.dispose();\n    heatmapScoresRaw.dispose();\n    offsetsRaw.dispose();\n    displacementFwdRaw.dispose();\n    displacementBwdRaw.dispose();\n    partSegmentation.dispose();\n\n    return instanceMasks;\n  }\n\n  public dispose() {\n    this.baseModel.dispose();\n  }\n}\n\n/**\n * Loads the MobileNet BodyPix model.\n */\nasync function loadMobileNet(config: ModelConfig): Promise<BodyPix> {\n  const outputStride = config.outputStride;\n  const quantBytes = config.quantBytes;\n  const multiplier = config.multiplier;\n  if (tf == null) {\n    throw new Error(\n        `Cannot find TensorFlow.js. If you are using a <script> tag, please ` +\n        `also include @tensorflow/tfjs on the page before using this\n        model.`);\n  }\n\n  const url = mobileNetSavedModel(outputStride, multiplier, quantBytes);\n  const graphModel = await tfconv.loadGraphModel(config.modelUrl || url);\n  const mobilenet = new MobileNet(graphModel, outputStride);\n  return new BodyPix(mobilenet);\n}\n\n/**\n * Loads the ResNet BodyPix model.\n */\nasync function loadResNet(config: ModelConfig): Promise<BodyPix> {\n  const outputStride = config.outputStride;\n  const quantBytes = config.quantBytes;\n  if (tf == null) {\n    throw new Error(\n        `Cannot find TensorFlow.js. If you are using a <script> tag, please ` +\n        `also include @tensorflow/tfjs on the page before using this\n        model.`);\n  }\n\n  const url = resNet50SavedModel(outputStride, quantBytes);\n  const graphModel = await tfconv.loadGraphModel(config.modelUrl || url);\n  const resnet = new ResNet(graphModel, outputStride);\n  return new BodyPix(resnet);\n}\n\n/**\n * Loads the BodyPix model instance from a checkpoint, with the ResNet\n * or MobileNet architecture. The model to be loaded is configurable using the\n * config dictionary ModelConfig. Please find more details in the\n * documentation of the ModelConfig.\n *\n * @param config ModelConfig dictionary that contains parameters for\n * the BodyPix loading process. Please find more details of each parameters\n * in the documentation of the ModelConfig interface. The predefined\n * `MOBILENET_V1_CONFIG` and `RESNET_CONFIG` can also be used as references\n * for defining your customized config.\n */\nexport async function load(config: ModelConfig = MOBILENET_V1_CONFIG):\n    Promise<BodyPix> {\n  config = validateModelConfig(config);\n  if (config.architecture === 'ResNet50') {\n    return loadResNet(config);\n  } else if (config.architecture === 'MobileNetV1') {\n    return loadMobileNet(config);\n  } else {\n    return null;\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\n// method copied from bGlur in https://codepen.io/zhaojun/pen/zZmRQe\nexport function cpuBlur(\n    canvas: HTMLCanvasElement,\n    image: HTMLImageElement|HTMLVideoElement|HTMLCanvasElement, blur: number) {\n  const ctx = canvas.getContext('2d');\n\n  let sum = 0;\n  const delta = 5;\n  const alphaLeft = 1 / (2 * Math.PI * delta * delta);\n  const step = blur < 3 ? 1 : 2;\n  for (let y = -blur; y <= blur; y += step) {\n    for (let x = -blur; x <= blur; x += step) {\n      const weight =\n          alphaLeft * Math.exp(-(x * x + y * y) / (2 * delta * delta));\n      sum += weight;\n    }\n  }\n  for (let y = -blur; y <= blur; y += step) {\n    for (let x = -blur; x <= blur; x += step) {\n      ctx.globalAlpha = alphaLeft *\n          Math.exp(-(x * x + y * y) / (2 * delta * delta)) / sum * blur;\n      ctx.drawImage(image, x, y);\n    }\n  }\n  ctx.globalAlpha = 1;\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {cpuBlur} from './blur';\nimport {Color, PartSegmentation, PersonSegmentation} from './types';\nimport {SemanticPartSegmentation, SemanticPersonSegmentation} from './types';\nimport {getInputSize} from './util';\n\nconst offScreenCanvases: {[name: string]: HTMLCanvasElement} = {};\n\ntype ImageType = HTMLImageElement|HTMLVideoElement|HTMLCanvasElement;\ntype HasDimensions = {\n  width: number,\n  height: number\n};\n\nfunction isSafari() {\n  return (/^((?!chrome|android).)*safari/i.test(navigator.userAgent));\n}\n\nfunction assertSameDimensions(\n    {width: widthA, height: heightA}: HasDimensions,\n    {width: widthB, height: heightB}: HasDimensions, nameA: string,\n    nameB: string) {\n  if (widthA !== widthB || heightA !== heightB) {\n    throw new Error(`error: dimensions must match. ${nameA} has dimensions ${\n        widthA}x${heightA}, ${nameB} has dimensions ${widthB}x${heightB}`);\n  }\n}\n\nfunction flipCanvasHorizontal(canvas: HTMLCanvasElement) {\n  const ctx = canvas.getContext('2d');\n  ctx.scale(-1, 1);\n  ctx.translate(-canvas.width, 0);\n}\n\nfunction drawWithCompositing(\n    ctx: CanvasRenderingContext2D, image: HTMLCanvasElement|ImageType,\n    compositOperation: string) {\n  ctx.globalCompositeOperation = compositOperation;\n  ctx.drawImage(image, 0, 0);\n}\n\nfunction createOffScreenCanvas(): HTMLCanvasElement {\n  const offScreenCanvas = document.createElement('canvas');\n  return offScreenCanvas;\n}\n\nfunction ensureOffscreenCanvasCreated(id: string): HTMLCanvasElement {\n  if (!offScreenCanvases[id]) {\n    offScreenCanvases[id] = createOffScreenCanvas();\n  }\n  return offScreenCanvases[id];\n}\n\nfunction drawAndBlurImageOnCanvas(\n    image: ImageType, blurAmount: number, canvas: HTMLCanvasElement) {\n  const {height, width} = image;\n  const ctx = canvas.getContext('2d');\n  canvas.width = width;\n  canvas.height = height;\n  ctx.clearRect(0, 0, width, height);\n  ctx.save();\n  if (isSafari()) {\n    cpuBlur(canvas, image, blurAmount);\n  } else {\n    // tslint:disable:no-any\n    (ctx as any).filter = `blur(${blurAmount}px)`;\n    ctx.drawImage(image, 0, 0, width, height);\n  }\n  ctx.restore();\n}\n\nfunction drawAndBlurImageOnOffScreenCanvas(\n    image: ImageType, blurAmount: number,\n    offscreenCanvasName: string): HTMLCanvasElement {\n  const canvas = ensureOffscreenCanvasCreated(offscreenCanvasName);\n  if (blurAmount === 0) {\n    renderImageToCanvas(image, canvas);\n  } else {\n    drawAndBlurImageOnCanvas(image, blurAmount, canvas);\n  }\n  return canvas;\n}\n\nfunction renderImageToCanvas(image: ImageType, canvas: HTMLCanvasElement) {\n  const {width, height} = image;\n  canvas.width = width;\n  canvas.height = height;\n  const ctx = canvas.getContext('2d');\n\n  ctx.drawImage(image, 0, 0, width, height);\n}\n/**\n * Draw an image on a canvas\n */\nfunction renderImageDataToCanvas(image: ImageData, canvas: HTMLCanvasElement) {\n  canvas.width = image.width;\n  canvas.height = image.height;\n  const ctx = canvas.getContext('2d');\n\n  ctx.putImageData(image, 0, 0);\n}\n\nfunction renderImageDataToOffScreenCanvas(\n    image: ImageData, canvasName: string): HTMLCanvasElement {\n  const canvas = ensureOffscreenCanvasCreated(canvasName);\n  renderImageDataToCanvas(image, canvas);\n\n  return canvas;\n}\n\n/**\n * Given the output from estimating multi-person segmentation, generates an\n * image with foreground and background color at each pixel determined by the\n * corresponding binary segmentation value at the pixel from the output.  In\n * other words, pixels where there is a person will be colored with foreground\n * color and where there is not a person will be colored with background color.\n *\n * @param personOrPartSegmentation The output from\n * `segmentPerson`, `segmentMultiPerson`,\n * `segmentPersonParts` or `segmentMultiPersonParts`. They can\n * be SemanticPersonSegmentation object, an array of PersonSegmentation object,\n * SemanticPartSegmentation object, or an array of PartSegmentation object.\n *\n * @param foreground Default to {r:0, g:0, b:0, a: 0}. The foreground color\n * (r,g,b,a) for visualizing pixels that belong to people.\n *\n * @param background Default to {r:0, g:0, b:0, a: 255}. The background color\n * (r,g,b,a) for visualizing pixels that don't belong to people.\n *\n * @param drawContour Default to false. Whether to draw the contour around each\n * person's segmentation mask or body part mask.\n *\n * @param foregroundIds Default to [1]. The integer values that represent\n * foreground. For person segmentation, 1 is the foreground. For body part\n * segmentation, it can be a subset of all body parts ids.\n *\n * @returns An ImageData with the same width and height of\n * all the PersonSegmentation in multiPersonSegmentation, with opacity and\n * transparency at each pixel determined by the corresponding binary\n * segmentation value at the pixel from the output.\n */\nexport function toMask(\n    personOrPartSegmentation: SemanticPersonSegmentation|\n    SemanticPartSegmentation|PersonSegmentation[]|PartSegmentation[],\n    foreground: Color = {\n      r: 0,\n      g: 0,\n      b: 0,\n      a: 0\n    },\n    background: Color = {\n      r: 0,\n      g: 0,\n      b: 0,\n      a: 255\n    },\n    drawContour = false, foregroundIds: number[] = [1]): ImageData {\n  if (Array.isArray(personOrPartSegmentation) &&\n      personOrPartSegmentation.length === 0) {\n    return null;\n  }\n\n  let multiPersonOrPartSegmentation:\n      Array<SemanticPersonSegmentation|SemanticPartSegmentation|\n            PersonSegmentation|PartSegmentation>;\n\n  if (!Array.isArray(personOrPartSegmentation)) {\n    multiPersonOrPartSegmentation = [personOrPartSegmentation];\n  } else {\n    multiPersonOrPartSegmentation = personOrPartSegmentation;\n  }\n\n  const {width, height} = multiPersonOrPartSegmentation[0];\n  const bytes = new Uint8ClampedArray(width * height * 4);\n\n  function drawStroke(\n      bytes: Uint8ClampedArray, row: number, column: number, width: number,\n      radius: number, color: Color = {r: 0, g: 255, b: 255, a: 255}) {\n    for (let i = -radius; i <= radius; i++) {\n      for (let j = -radius; j <= radius; j++) {\n        if (i !== 0 && j !== 0) {\n          const n = (row + i) * width + (column + j);\n          bytes[4 * n + 0] = color.r;\n          bytes[4 * n + 1] = color.g;\n          bytes[4 * n + 2] = color.b;\n          bytes[4 * n + 3] = color.a;\n        }\n      }\n    }\n  }\n\n  function isSegmentationBoundary(\n      segmentationData: Uint8Array|Int32Array,\n      row: number,\n      column: number,\n      width: number,\n      foregroundIds: number[] = [1],\n      radius = 1,\n      ): boolean {\n    let numberBackgroundPixels = 0;\n    for (let i = -radius; i <= radius; i++) {\n      for (let j = -radius; j <= radius; j++) {\n        if (i !== 0 && j !== 0) {\n          const n = (row + i) * width + (column + j);\n          if (!foregroundIds.some(id => id === segmentationData[n])) {\n            numberBackgroundPixels += 1;\n          }\n        }\n      }\n    }\n    return numberBackgroundPixels > 0;\n  }\n\n  for (let i = 0; i < height; i += 1) {\n    for (let j = 0; j < width; j += 1) {\n      const n = i * width + j;\n      bytes[4 * n + 0] = background.r;\n      bytes[4 * n + 1] = background.g;\n      bytes[4 * n + 2] = background.b;\n      bytes[4 * n + 3] = background.a;\n      for (let k = 0; k < multiPersonOrPartSegmentation.length; k++) {\n        if (foregroundIds.some(\n                id => id === multiPersonOrPartSegmentation[k].data[n])) {\n          bytes[4 * n] = foreground.r;\n          bytes[4 * n + 1] = foreground.g;\n          bytes[4 * n + 2] = foreground.b;\n          bytes[4 * n + 3] = foreground.a;\n          const isBoundary = isSegmentationBoundary(\n              multiPersonOrPartSegmentation[k].data, i, j, width,\n              foregroundIds);\n          if (drawContour && i - 1 >= 0 && i + 1 < height && j - 1 >= 0 &&\n              j + 1 < width && isBoundary) {\n            drawStroke(bytes, i, j, width, 1);\n          }\n        }\n      }\n    }\n  }\n\n  return new ImageData(bytes, width, height);\n}\n\nconst RAINBOW_PART_COLORS: Array<[number, number, number]> = [\n  [110, 64, 170], [143, 61, 178], [178, 60, 178], [210, 62, 167],\n  [238, 67, 149], [255, 78, 125], [255, 94, 99],  [255, 115, 75],\n  [255, 140, 56], [239, 167, 47], [217, 194, 49], [194, 219, 64],\n  [175, 240, 91], [135, 245, 87], [96, 247, 96],  [64, 243, 115],\n  [40, 234, 141], [28, 219, 169], [26, 199, 194], [33, 176, 213],\n  [47, 150, 224], [65, 125, 224], [84, 101, 214], [99, 81, 195]\n];\n\n/**\n * Given the output from person body part segmentation (or multi-person\n * instance body part segmentation) and an array of colors indexed by part id,\n * generates an image with the corresponding color for each part at each pixel,\n * and white pixels where there is no part.\n *\n * @param partSegmentation The output from segmentPersonParts\n * or segmentMultiPersonParts. The former is a SemanticPartSegmentation\n * object and later is an array of PartSegmentation object.\n *\n * @param partColors A multi-dimensional array of rgb colors indexed by\n * part id.  Must have 24 colors, one for every part.\n *\n * @returns An ImageData with the same width and height of all the element in\n * multiPersonPartSegmentation, with the corresponding color for each part at\n * each pixel, and black pixels where there is no part.\n */\nexport function toColoredPartMask(\n    partSegmentation: SemanticPartSegmentation|PartSegmentation[],\n    partColors: Array<[number, number, number]> =\n        RAINBOW_PART_COLORS): ImageData {\n  if (Array.isArray(partSegmentation) && partSegmentation.length === 0) {\n    return null;\n  }\n\n  let multiPersonPartSegmentation;\n  if (!Array.isArray(partSegmentation)) {\n    multiPersonPartSegmentation = [partSegmentation];\n  } else {\n    multiPersonPartSegmentation = partSegmentation;\n  }\n  const {width, height} = multiPersonPartSegmentation[0];\n  const bytes = new Uint8ClampedArray(width * height * 4);\n\n  for (let i = 0; i < height * width; ++i) {\n    // invert mask.  Invert the segmentation mask.\n    const j = i * 4;\n    bytes[j + 0] = 255;\n    bytes[j + 1] = 255;\n    bytes[j + 2] = 255;\n    bytes[j + 3] = 255;\n    for (let k = 0; k < multiPersonPartSegmentation.length; k++) {\n      const partId = multiPersonPartSegmentation[k].data[i];\n      if (partId !== -1) {\n        const color = partColors[partId];\n        if (!color) {\n          throw new Error(`No color could be found for part id ${partId}`);\n        }\n        bytes[j + 0] = color[0];\n        bytes[j + 1] = color[1];\n        bytes[j + 2] = color[2];\n        bytes[j + 3] = 255;\n      }\n    }\n  }\n  return new ImageData(bytes, width, height);\n}\n\nconst CANVAS_NAMES = {\n  blurred: 'blurred',\n  blurredMask: 'blurred-mask',\n  mask: 'mask',\n  lowresPartMask: 'lowres-part-mask',\n};\n\n/**\n * Given an image and a maskImage of type ImageData, draws the image with the\n * mask on top of it onto a canvas.\n *\n * @param canvas The canvas to be drawn onto.\n *\n * @param image The original image to apply the mask to.\n *\n * @param maskImage An ImageData containing the mask.  Ideally this should be\n * generated by toMask or toColoredPartMask.\n *\n * @param maskOpacity The opacity of the mask when drawing it on top of the\n * image. Defaults to 0.7. Should be a float between 0 and 1.\n *\n * @param maskBlurAmount How many pixels to blur the mask by. Defaults to 0.\n * Should be an integer between 0 and 20.\n *\n * @param flipHorizontal If the result should be flipped horizontally.  Defaults\n * to false.\n */\nexport function drawMask(\n    canvas: HTMLCanvasElement, image: ImageType, maskImage: ImageData|null,\n    maskOpacity = 0.7, maskBlurAmount = 0, flipHorizontal = false) {\n  const [height, width] = getInputSize(image);\n  canvas.width = width;\n  canvas.height = height;\n\n  const ctx = canvas.getContext('2d');\n  ctx.save();\n  if (flipHorizontal) {\n    flipCanvasHorizontal(canvas);\n  }\n\n  ctx.drawImage(image, 0, 0);\n\n  ctx.globalAlpha = maskOpacity;\n  if (maskImage) {\n    assertSameDimensions({width, height}, maskImage, 'image', 'mask');\n\n    const mask = renderImageDataToOffScreenCanvas(maskImage, CANVAS_NAMES.mask);\n\n    const blurredMask = drawAndBlurImageOnOffScreenCanvas(\n        mask, maskBlurAmount, CANVAS_NAMES.blurredMask);\n    ctx.drawImage(blurredMask, 0, 0, width, height);\n  }\n  ctx.restore();\n}\n\n/**\n * Given an image and a maskImage of type ImageData, draws the image with the\n * pixelated mask on top of it onto a canvas.\n *\n * @param canvas The canvas to be drawn onto.\n *\n * @param image The original image to apply the mask to.\n *\n * @param maskImage An ImageData containing the mask.  Ideally this should be\n * generated by toColoredPartMask.\n *\n * @param maskOpacity The opacity of the mask when drawing it on top of the\n * image. Defaults to 0.7. Should be a float between 0 and 1.\n *\n * @param maskBlurAmount How many pixels to blur the mask by. Defaults to 0.\n * Should be an integer between 0 and 20.\n *\n * @param flipHorizontal If the result should be flipped horizontally.  Defaults\n * to false.\n *\n * @param pixelCellWidth The width of each pixel cell. Default to 10 px.\n */\nexport function drawPixelatedMask(\n    canvas: HTMLCanvasElement, image: ImageType, maskImage: ImageData,\n    maskOpacity = 0.7, maskBlurAmount = 0, flipHorizontal = false,\n    pixelCellWidth = 10.0) {\n  const [height, width] = getInputSize(image);\n  assertSameDimensions({width, height}, maskImage, 'image', 'mask');\n\n  const mask = renderImageDataToOffScreenCanvas(maskImage, CANVAS_NAMES.mask);\n  const blurredMask = drawAndBlurImageOnOffScreenCanvas(\n      mask, maskBlurAmount, CANVAS_NAMES.blurredMask);\n\n  canvas.width = blurredMask.width;\n  canvas.height = blurredMask.height;\n\n  const ctx = canvas.getContext('2d');\n  ctx.save();\n  if (flipHorizontal) {\n    flipCanvasHorizontal(canvas);\n  }\n\n  const offscreenCanvas =\n      ensureOffscreenCanvasCreated(CANVAS_NAMES.lowresPartMask);\n  const offscreenCanvasCtx = offscreenCanvas.getContext('2d');\n  offscreenCanvas.width = blurredMask.width * (1.0 / pixelCellWidth);\n  offscreenCanvas.height = blurredMask.height * (1.0 / pixelCellWidth);\n  offscreenCanvasCtx.drawImage(\n      blurredMask, 0, 0, blurredMask.width, blurredMask.height, 0, 0,\n      offscreenCanvas.width, offscreenCanvas.height);\n  ctx.imageSmoothingEnabled = false;\n  ctx.drawImage(\n      offscreenCanvas, 0, 0, offscreenCanvas.width, offscreenCanvas.height, 0,\n      0, canvas.width, canvas.height);\n\n  // Draws vertical grid lines that are `pixelCellWidth` apart from each other.\n  for (let i = 0; i < offscreenCanvas.width; i++) {\n    ctx.beginPath();\n    ctx.strokeStyle = '#ffffff';\n    ctx.moveTo(pixelCellWidth * i, 0);\n    ctx.lineTo(pixelCellWidth * i, canvas.height);\n    ctx.stroke();\n  }\n\n  // Draws horizontal grid lines that are `pixelCellWidth` apart from each\n  // other.\n  for (let i = 0; i < offscreenCanvas.height; i++) {\n    ctx.beginPath();\n    ctx.strokeStyle = '#ffffff';\n    ctx.moveTo(0, pixelCellWidth * i);\n    ctx.lineTo(canvas.width, pixelCellWidth * i);\n    ctx.stroke();\n  }\n\n  ctx.globalAlpha = 1.0 - maskOpacity;\n  ctx.drawImage(image, 0, 0, blurredMask.width, blurredMask.height);\n  ctx.restore();\n}\n\nfunction createPersonMask(\n    multiPersonSegmentation: PersonSegmentation[]|SemanticPersonSegmentation,\n    edgeBlurAmount: number): HTMLCanvasElement {\n  const backgroundMaskImage = toMask(\n      multiPersonSegmentation, {r: 0, g: 0, b: 0, a: 255},\n      {r: 0, g: 0, b: 0, a: 0});\n\n  const backgroundMask =\n      renderImageDataToOffScreenCanvas(backgroundMaskImage, CANVAS_NAMES.mask);\n  if (edgeBlurAmount === 0) {\n    return backgroundMask;\n  } else {\n    return drawAndBlurImageOnOffScreenCanvas(\n        backgroundMask, edgeBlurAmount, CANVAS_NAMES.blurredMask);\n  }\n}\n\n/**\n * Given a personSegmentation and an image, draws the image with its background\n * blurred onto the canvas.\n *\n * @param canvas The canvas to draw the background-blurred image onto.\n *\n * @param image The image to blur the background of and draw.\n *\n * @param personSegmentation A SemanticPersonSegmentation or an array of\n * PersonSegmentation object.\n *\n * @param backgroundBlurAmount How many pixels in the background blend into each\n * other.  Defaults to 3. Should be an integer between 1 and 20.\n *\n * @param edgeBlurAmount How many pixels to blur on the edge between the person\n * and the background by.  Defaults to 3. Should be an integer between 0 and 20.\n *\n * @param flipHorizontal If the output should be flipped horizontally.  Defaults\n * to false.\n */\nexport function drawBokehEffect(\n    canvas: HTMLCanvasElement, image: ImageType,\n    multiPersonSegmentation: SemanticPersonSegmentation|PersonSegmentation[],\n    backgroundBlurAmount = 3, edgeBlurAmount = 3, flipHorizontal = false) {\n  const blurredImage = drawAndBlurImageOnOffScreenCanvas(\n      image, backgroundBlurAmount, CANVAS_NAMES.blurred);\n  canvas.width = blurredImage.width;\n  canvas.height = blurredImage.height;\n\n  const ctx = canvas.getContext('2d');\n\n  if (Array.isArray(multiPersonSegmentation) &&\n      multiPersonSegmentation.length === 0) {\n    ctx.drawImage(blurredImage, 0, 0);\n    return;\n  }\n\n  const personMask = createPersonMask(multiPersonSegmentation, edgeBlurAmount);\n\n  ctx.save();\n  if (flipHorizontal) {\n    flipCanvasHorizontal(canvas);\n  }\n  // draw the original image on the final canvas\n  const [height, width] = getInputSize(image);\n  ctx.drawImage(image, 0, 0, width, height);\n\n  // \"destination-in\" - \"The existing canvas content is kept where both the\n  // new shape and existing canvas content overlap. Everything else is made\n  // transparent.\"\n  // crop what's not the person using the mask from the original image\n  drawWithCompositing(ctx, personMask, 'destination-in');\n  // \"destination-over\" - \"The existing canvas content is kept where both the\n  // new shape and existing canvas content overlap. Everything else is made\n  // transparent.\"\n  // draw the blurred background on top of the original image where it doesn't\n  // overlap.\n  drawWithCompositing(ctx, blurredImage, 'destination-over');\n  ctx.restore();\n}\n\nfunction createBodyPartMask(\n    multiPersonPartSegmentation: SemanticPartSegmentation|PartSegmentation[],\n    bodyPartIdsToMask: number[], edgeBlurAmount: number): HTMLCanvasElement {\n  const backgroundMaskImage = toMask(\n      multiPersonPartSegmentation, {r: 0, g: 0, b: 0, a: 0},\n      {r: 0, g: 0, b: 0, a: 255}, true, bodyPartIdsToMask);\n\n  const backgroundMask =\n      renderImageDataToOffScreenCanvas(backgroundMaskImage, CANVAS_NAMES.mask);\n  if (edgeBlurAmount === 0) {\n    return backgroundMask;\n  } else {\n    return drawAndBlurImageOnOffScreenCanvas(\n        backgroundMask, edgeBlurAmount, CANVAS_NAMES.blurredMask);\n  }\n}\n\n/**\n * Given a personSegmentation and an image, draws the image with its background\n * blurred onto the canvas.\n *\n * @param canvas The canvas to draw the background-blurred image onto.\n *\n * @param image The image to blur the background of and draw.\n *\n * @param partSegmentation A SemanticPartSegmentation or an array of\n * PartSegmentation object.\n *\n * @param bodyPartIdsToBlur Default to [0, 1] (left-face and right-face). An\n * array of body part ids to blur. Each must be one of the 24 body part ids.\n *\n * @param backgroundBlurAmount How many pixels in the background blend into each\n * other.  Defaults to 3. Should be an integer between 1 and 20.\n *\n * @param edgeBlurAmount How many pixels to blur on the edge between the person\n * and the background by.  Defaults to 3. Should be an integer between 0 and 20.\n *\n * @param flipHorizontal If the output should be flipped horizontally.  Defaults\n * to false.\n */\nexport function blurBodyPart(\n    canvas: HTMLCanvasElement, image: ImageType,\n    partSegmentation: SemanticPartSegmentation|PartSegmentation[],\n    bodyPartIdsToBlur = [0, 1], backgroundBlurAmount = 3, edgeBlurAmount = 3,\n    flipHorizontal = false) {\n  const blurredImage = drawAndBlurImageOnOffScreenCanvas(\n      image, backgroundBlurAmount, CANVAS_NAMES.blurred);\n  canvas.width = blurredImage.width;\n  canvas.height = blurredImage.height;\n\n  const ctx = canvas.getContext('2d');\n\n  if (Array.isArray(partSegmentation) && partSegmentation.length === 0) {\n    ctx.drawImage(blurredImage, 0, 0);\n    return;\n  }\n  const bodyPartMask =\n      createBodyPartMask(partSegmentation, bodyPartIdsToBlur, edgeBlurAmount);\n\n  ctx.save();\n  if (flipHorizontal) {\n    flipCanvasHorizontal(canvas);\n  }\n  // draw the original image on the final canvas\n  const [height, width] = getInputSize(image);\n  ctx.drawImage(image, 0, 0, width, height);\n\n  // \"destination-in\" - \"The existing canvas content is kept where both the\n  // new shape and existing canvas content overlap. Everything else is made\n  // transparent.\"\n  // crop what's not the person using the mask from the original image\n  drawWithCompositing(ctx, bodyPartMask, 'destination-in');\n  // \"destination-over\" - \"The existing canvas content is kept where both the\n  // new shape and existing canvas content overlap. Everything else is made\n  // transparent.\"\n  // draw the blurred background on top of the original image where it doesn't\n  // overlap.\n  drawWithCompositing(ctx, blurredImage, 'destination-over');\n  ctx.restore();\n}\n","/**\n * @license\n * Copyright 2020 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\n\nexport const PART_CHANNELS: string[] = [\n  'left_face',\n  'right_face',\n  'left_upper_arm_front',\n  'left_upper_arm_back',\n  'right_upper_arm_front',\n  'right_upper_arm_back',\n  'left_lower_arm_front',\n  'left_lower_arm_back',\n  'right_lower_arm_front',\n  'right_lower_arm_back',\n  'left_hand',\n  'right_hand',\n  'torso_front',\n  'torso_back',\n  'left_upper_leg_front',\n  'left_upper_leg_back',\n  'right_upper_leg_front',\n  'right_upper_leg_back',\n  'left_lower_leg_front',\n  'left_lower_leg_back',\n  'right_lower_leg_front',\n  'right_lower_leg_back',\n  'left_feet',\n  'right_feet'\n];\n","/** @license See the LICENSE file. */\n\n// This code is auto-generated, do not modify this file!\nconst version = '2.1.0';\nexport {version};\n"]},"metadata":{},"sourceType":"module"}